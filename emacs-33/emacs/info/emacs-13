This is Info file ../info/emacs, produced by Makeinfo version 1.68 from
the input file emacs.texi.

   This is the thirteenth edition of the `GNU Emacs Manual', updated
for Emacs version 20.3

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307 USA

   Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998
Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.


File: emacs,  Node: Programs,  Next: Building,  Prev: Text,  Up: Top

Editing Programs
****************

   Emacs has many commands designed to understand the syntax of
programming languages such as Lisp and C.  These commands can

   * Move over or kill balanced expressions or "sexps" (*note Lists::.).

   * Move over or mark top-level expressions--"defuns", in Lisp;
     functions, in C (*note Defuns::.).

   * Show how parentheses balance (*note Matching::.).

   * Insert, kill or align comments (*note Comments::.).

   * Follow the usual indentation conventions of the language (*note
     Program Indent::.).

   The commands for words, sentences and paragraphs are very useful in
editing code even though their canonical application is for editing
human language text.  Most symbols contain words (*note Words::.);
sentences can be found in strings and comments (*note Sentences::.).
Paragraphs per se don't exist in code, but the paragraph commands are
useful anyway, because programming language major modes define
paragraphs to begin and end at blank lines (*note Paragraphs::.).
Judicious use of blank lines to make the program clearer will also
provide useful chunks of text for the paragraph commands to work on.

   The selective display feature is useful for looking at the overall
structure of a function (*note Selective Display::.).  This feature
causes only the lines that are indented less than a specified amount to
appear on the screen.

* Menu:

* Program Modes::       Major modes for editing programs.
* Lists::	        Expressions with balanced parentheses.
* List Commands::       The commands for working with list and sexps.
* Defuns::	        Each program is made up of separate functions.
			  There are editing commands to operate on them.
* Program Indent::      Adjusting indentation to show the nesting.
* Matching::	        Insertion of a close-delimiter flashes matching open.
* Comments::	        Inserting, killing, and aligning comments.
* Balanced Editing::    Inserting two matching parentheses at once, etc.
* Symbol Completion::   Completion on symbol names of your program or language.
* Which Function::      Which Function mode shows which function you are in.
* Documentation::       Getting documentation of functions you plan to call.
* Change Log::	        Maintaining a change history for your program.
* Tags::	        Go direct to any function in your program in one
			  command.  Tags remembers which file it is in.
* Emerge::	        A convenient way of merging two versions of a program.
* C/Java Modes::        Special commands of C, C++, Objective-C and Java modes.
* Fortran::	        Fortran mode and its special features.
* Asm Mode::	        Asm mode and its special features.


File: emacs,  Node: Program Modes,  Next: Lists,  Up: Programs

Major Modes for Programming Languages
=====================================

   Emacs also has major modes for the programming languages Lisp, Scheme
(a variant of Lisp), Awk, C, C++, Fortran, Icon, Java, Objective-C,
Pascal, Perl and Tcl.  There is also a major mode for makefiles, called
Makefile mode.  An second alternative mode for Perl is called CPerl
mode.

   Ideally, a major mode should be implemented for each programming
language that you might want to edit with Emacs; but often the mode for
one language can serve for other syntactically similar languages.  The
language modes that exist are those that someone decided to take the
trouble to write.

   There are several forms of Lisp mode, which differ in the way they
interface to Lisp execution.  *Note Executing Lisp::.

   Each of the programming language major modes defines the <TAB> key
to run an indentation function that knows the indentation conventions of
that language and updates the current line's indentation accordingly.
For example, in C mode <TAB> is bound to `c-indent-line'.  `C-j' is
normally defined to do <RET> followed by <TAB>; thus, it too indents in
a mode-specific fashion.

   In most programming languages, indentation is likely to vary from
line to line.  So the major modes for those languages rebind <DEL> to
treat a tab as if it were the equivalent number of spaces (using the
command `backward-delete-char-untabify').  This makes it possible to
rub out indentation one column at a time without worrying whether it is
made up of spaces or tabs.  Use `C-b C-d' to delete a tab character
before point, in these modes.

   Programming language modes define paragraphs to be separated only by
blank lines, so that the paragraph commands remain useful.  Auto Fill
mode, if enabled in a programming language major mode, indents the new
lines which it creates.

   Turning on a major mode runs a normal hook called the "mode hook",
which is the value of a Lisp variable.  Each major mode has a mode hook,
and the hook's name is always made from the mode command's name by
adding `-hook'.  For example, turning on C mode runs the hook
`c-mode-hook', while turning on Lisp mode runs the hook
`lisp-mode-hook'.  *Note Hooks::.


File: emacs,  Node: Lists,  Next: List Commands,  Prev: Program Modes,  Up: Programs

Lists and Sexps
===============

   By convention, Emacs keys for dealing with balanced expressions are
usually Control-Meta characters.  They tend to be analogous in function
to their Control and Meta equivalents.  These commands are usually
thought of as pertaining to expressions in programming languages, but
can be useful with any language in which some sort of parentheses exist
(including human languages).

   These commands fall into two classes.  Some deal only with "lists"
(parenthetical groupings).  They see nothing except parentheses,
brackets, braces (whichever ones must balance in the language you are
working with), and escape characters that might be used to quote those.

   The other commands deal with expressions or "sexps".  The word `sexp'
is derived from "s-expression", the ancient term for an expression in
Lisp.  But in Emacs, the notion of `sexp' is not limited to Lisp.  It
refers to an expression in whatever language your program is written in.
Each programming language has its own major mode, which customizes the
syntax tables so that expressions in that language count as sexps.

   Sexps typically include symbols, numbers, and string constants, as
well as anything contained in parentheses, brackets or braces.

   In languages that use prefix and infix operators, such as C, it is
not possible for all expressions to be sexps.  For example, C mode does
not recognize `foo + bar' as a sexp, even though it *is* a C expression;
it recognizes `foo' as one sexp and `bar' as another, with the `+' as
punctuation between them.  This is a fundamental ambiguity: both `foo +
bar' and `foo' are legitimate choices for the sexp to move over if
point is at the `f'.  Note that `(foo + bar)' is a single sexp in C
mode.

   Some languages have obscure forms of expression syntax that nobody
has bothered to make Emacs understand properly.


File: emacs,  Node: List Commands,  Next: Defuns,  Prev: Lists,  Up: Programs

List And Sexp Commands
======================

`C-M-f'
     Move forward over a sexp (`forward-sexp').

`C-M-b'
     Move backward over a sexp (`backward-sexp').

`C-M-k'
     Kill sexp forward (`kill-sexp').

`C-M-<DEL>'
     Kill sexp backward (`backward-kill-sexp').

`C-M-u'
     Move up and backward in list structure (`backward-up-list').

`C-M-d'
     Move down and forward in list structure (`down-list').

`C-M-n'
     Move forward over a list (`forward-list').

`C-M-p'
     Move backward over a list (`backward-list').

`C-M-t'
     Transpose expressions (`transpose-sexps').

`C-M-@'
     Put mark after following expression (`mark-sexp').

   To move forward over a sexp, use `C-M-f' (`forward-sexp').  If the
first significant character after point is an opening delimiter (`(' in
Lisp; `(', `[' or `{' in C), `C-M-f' moves past the matching closing
delimiter.  If the character begins a symbol, string, or number,
`C-M-f' moves over that.

   The command `C-M-b' (`backward-sexp') moves backward over a sexp.
The detailed rules are like those above for `C-M-f', but with
directions reversed.  If there are any prefix characters (single-quote,
backquote and comma, in Lisp) preceding the sexp, `C-M-b' moves back
over them as well.  The sexp commands move across comments as if they
were whitespace in most modes.

   `C-M-f' or `C-M-b' with an argument repeats that operation the
specified number of times; with a negative argument, it moves in the
opposite direction.

   Killing a whole sexp can be done with `C-M-k' (`kill-sexp') or
`C-M-<DEL>' (`backward-kill-sexp').  `C-M-k' kills the characters that
`C-M-f' would move over, and `C-M-<DEL>' kills the characters that
`C-M-b' would move over.

   The "list commands" move over lists, as the sexp commands do, but
skip blithely over any number of other kinds of sexps (symbols,
strings, etc.).  They are `C-M-n' (`forward-list') and `C-M-p'
(`backward-list').  The main reason they are useful is that they
usually ignore comments (since the comments usually do not contain any
lists).

   `C-M-n' and `C-M-p' stay at the same level in parentheses, when
that's possible.  To move *up* one (or N) levels, use `C-M-u'
(`backward-up-list').  `C-M-u' moves backward up past one unmatched
opening delimiter.  A positive argument serves as a repeat count; a
negative argument reverses direction of motion and also requests
repetition, so it moves forward and up one or more levels.

   To move *down* in list structure, use `C-M-d' (`down-list').  In
Lisp mode, where `(' is the only opening delimiter, this is nearly the
same as searching for a `('.  An argument specifies the number of
levels of parentheses to go down.

   A somewhat random-sounding command which is nevertheless handy is
`C-M-t' (`transpose-sexps'), which drags the previous sexp across the
next one.  An argument serves as a repeat count, and a negative
argument drags backwards (thus canceling out the effect of `C-M-t' with
a positive argument).  An argument of zero, rather than doing nothing,
transposes the sexps ending after point and the mark.

   To set the region around the next sexp in the buffer, use `C-M-@'
(`mark-sexp'), which sets mark at the same place that `C-M-f' would
move to.  `C-M-@' takes arguments like `C-M-f'.  In particular, a
negative argument is useful for putting the mark at the beginning of
the previous sexp.

   The list and sexp commands' understanding of syntax is completely
controlled by the syntax table.  Any character can, for example, be
declared to be an opening delimiter and act like an open parenthesis.
*Note Syntax::.


File: emacs,  Node: Defuns,  Next: Program Indent,  Prev: List Commands,  Up: Programs

Defuns
======

   In Emacs, a parenthetical grouping at the top level in the buffer is
called a "defun".  The name derives from the fact that most top-level
lists in a Lisp file are instances of the special form `defun', but any
top-level parenthetical grouping counts as a defun in Emacs parlance
regardless of what its contents are, and regardless of the programming
language in use.  For example, in C, the body of a function definition
is a defun.

`C-M-a'
     Move to beginning of current or preceding defun
     (`beginning-of-defun').

`C-M-e'
     Move to end of current or following defun (`end-of-defun').

`C-M-h'
     Put region around whole current or following defun (`mark-defun').

   The commands to move to the beginning and end of the current defun
are `C-M-a' (`beginning-of-defun') and `C-M-e' (`end-of-defun').

   If you wish to operate on the current defun, use `C-M-h'
(`mark-defun') which puts point at the beginning and mark at the end of
the current or next defun.  For example, this is the easiest way to get
ready to move the defun to a different place in the text.  In C mode,
`C-M-h' runs the function `c-mark-function', which is almost the same
as `mark-defun'; the difference is that it backs up over the argument
declarations, function name and returned data type so that the entire C
function is inside the region.  *Note Marking Objects::.

   Emacs assumes that any open-parenthesis found in the leftmost column
is the start of a defun.  Therefore, *never put an open-parenthesis at
the left margin in a Lisp file unless it is the start of a top-level
list.  Never put an open-brace or other opening delimiter at the
beginning of a line of C code unless it starts the body of a function.*
The most likely problem case is when you want an opening delimiter at
the start of a line inside a string.  To avoid trouble, put an escape
character (`\', in C and Emacs Lisp, `/' in some other Lisp dialects)
before the opening delimiter.  It will not affect the contents of the
string.

   In the remotest past, the original Emacs found defuns by moving
upward a level of parentheses until there were no more levels to go up.
This always required scanning all the way back to the beginning of the
buffer, even for a small function.  To speed up the operation, Emacs
was changed to assume that any `(' (or other character assigned the
syntactic class of opening-delimiter) at the left margin is the start
of a defun.  This heuristic is nearly always right and avoids the
costly scan; however, it mandates the convention described above.


File: emacs,  Node: Program Indent,  Next: Matching,  Prev: Defuns,  Up: Programs

Indentation for Programs
========================

   The best way to keep a program properly indented is to use Emacs to
reindent it as you change it.  Emacs has commands to indent properly
either a single line, a specified number of lines, or all of the lines
inside a single parenthetical grouping.

* Menu:

* Basic Indent::	Indenting a single line.
* Multi-line Indent::   Commands to reindent many lines at once.
* Lisp Indent::		Specifying how each Lisp function should be indented.
* C Indent::		Extra features for indenting C code.
* Custom C Indent::	Controlling indentation style for C code.

   Emacs also provides a Lisp pretty-printer in the library `pp'.  This
program reformats a Lisp object with indentation chosen to look nice.


File: emacs,  Node: Basic Indent,  Next: Multi-line Indent,  Up: Program Indent

Basic Program Indentation Commands
----------------------------------

`<TAB>'
     Adjust indentation of current line.

`C-j'
     Equivalent to <RET> followed by <TAB> (`newline-and-indent').

   The basic indentation command is <TAB>, which gives the current line
the correct indentation as determined from the previous lines.  The
function that <TAB> runs depends on the major mode; it is
`lisp-indent-line' in Lisp mode, `c-indent-line' in C mode, etc.  These
functions understand different syntaxes for different languages, but
they all do about the same thing.  <TAB> in any programming-language
major mode inserts or deletes whitespace at the beginning of the
current line, independent of where point is in the line.  If point is
inside the whitespace at the beginning of the line, <TAB> leaves it at
the end of that whitespace; otherwise, <TAB> leaves point fixed with
respect to the characters around it.

   Use `C-q <TAB>' to insert a tab at point.

   When entering lines of new code, use `C-j' (`newline-and-indent'),
which is equivalent to a <RET> followed by a <TAB>.  `C-j' creates a
blank line and then gives it the appropriate indentation.

   <TAB> indents the second and following lines of the body of a
parenthetical grouping each under the preceding one; therefore, if you
alter one line's indentation to be nonstandard, the lines below will
tend to follow it.  This behavior is convenient in cases where you have
overridden the standard result of <TAB> because you find it unaesthetic
for a particular line.

   Remember that an open-parenthesis, open-brace or other opening
delimiter at the left margin is assumed by Emacs (including the
indentation routines) to be the start of a function.  Therefore, you
must never have an opening delimiter in column zero that is not the
beginning of a function, not even inside a string.  This restriction is
vital for making the indentation commands fast; you must simply accept
it.  *Note Defuns::, for more information on this.


File: emacs,  Node: Multi-line Indent,  Next: Lisp Indent,  Prev: Basic Indent,  Up: Program Indent

Indenting Several Lines
-----------------------

   When you wish to reindent several lines of code which have been
altered or moved to a different level in the list structure, you have
several commands available.

`C-M-q'
     Reindent all the lines within one list (`indent-sexp').

`C-u <TAB>'
     Shift an entire list rigidly sideways so that its first line is
     properly indented.

`C-M-\'
     Reindent all lines in the region (`indent-region').

   You can reindent the contents of a single list by positioning point
before the beginning of it and typing `C-M-q' (`indent-sexp' in Lisp
mode, `c-indent-exp' in C mode; also bound to other suitable commands
in other modes).  The indentation of the line the sexp starts on is not
changed; therefore, only the relative indentation within the list, and
not its position, is changed.  To correct the position as well, type a
<TAB> before the `C-M-q'.

   If the relative indentation within a list is correct but the
indentation of its first line is not, go to that line and type `C-u
<TAB>'.  <TAB> with a numeric argument reindents the current line as
usual, then reindents by the same amount all the lines in the grouping
starting on the current line.  In other words, it reindents the whole
grouping rigidly as a unit.  It is clever, though, and does not alter
lines that start inside strings, or C preprocessor lines when in C mode.

   Another way to specify the range to be reindented is with the region.
The command `C-M-\' (`indent-region') applies <TAB> to every line whose
first character is between point and mark.


File: emacs,  Node: Lisp Indent,  Next: C Indent,  Prev: Multi-line Indent,  Up: Program Indent

Customizing Lisp Indentation
----------------------------

   The indentation pattern for a Lisp expression can depend on the
function called by the expression.  For each Lisp function, you can
choose among several predefined patterns of indentation, or define an
arbitrary one with a Lisp program.

   The standard pattern of indentation is as follows: the second line
of the expression is indented under the first argument, if that is on
the same line as the beginning of the expression; otherwise, the second
line is indented underneath the function name.  Each following line is
indented under the previous line whose nesting depth is the same.

   If the variable `lisp-indent-offset' is non-`nil', it overrides the
usual indentation pattern for the second line of an expression, so that
such lines are always indented `lisp-indent-offset' more columns than
the containing list.

   The standard pattern is overridden for certain functions.  Functions
whose names start with `def' always indent the second line by
`lisp-body-indent' extra columns beyond the open-parenthesis starting
the expression.

   The standard pattern can be overridden in various ways for individual
functions, according to the `lisp-indent-function' property of the
function name.  There are four possibilities for this property:

`nil'
     This is the same as no property; the standard indentation pattern
     is used.

`defun'
     The pattern used for function names that start with `def' is used
     for this function also.

a number, NUMBER
     The first NUMBER arguments of the function are "distinguished"
     arguments; the rest are considered the "body" of the expression.
     A line in the expression is indented according to whether the
     first argument on it is distinguished or not.  If the argument is
     part of the body, the line is indented `lisp-body-indent' more
     columns than the open-parenthesis starting the containing
     expression.  If the argument is distinguished and is either the
     first or second argument, it is indented *twice* that many extra
     columns.  If the argument is distinguished and not the first or
     second argument, the standard pattern is followed for that line.

a symbol, SYMBOL
     SYMBOL should be a function name; that function is called to
     calculate the indentation of a line within this expression.  The
     function receives two arguments:
    STATE
          The value returned by `parse-partial-sexp' (a Lisp primitive
          for indentation and nesting computation) when it parses up to
          the beginning of this line.

    POS
          The position at which the line being indented begins.

     It should return either a number, which is the number of columns of
     indentation for that line, or a list whose car is such a number.
     The difference between returning a number and returning a list is
     that a number says that all following lines at the same nesting
     level should be indented just like this one; a list says that
     following lines might call for different indentations.  This makes
     a difference when the indentation is being computed by `C-M-q'; if
     the value is a number, `C-M-q' need not recalculate indentation
     for the following lines until the end of the list.


File: emacs,  Node: C Indent,  Next: Custom C Indent,  Prev: Lisp Indent,  Up: Program Indent

Commands for C Indentation
--------------------------

   Here are the commands for indentation in C mode and related modes:

`C-c C-q'
     Reindent the current top-level function definition or aggregate
     type declaration (`c-indent-defun').

`C-M-q'
     Reindent each line in the balanced expression that follows point
     (`c-indent-exp').  A prefix argument inhibits error checking and
     warning messages about invalid syntax.

`<TAB>'
     Reindent the current line, and/or in some cases insert a tab
     character (`c-indent-command').

     If `c-tab-always-indent' is `t', this command always reindents the
     current line and does nothing else.  This is the default.

     If that variable is `nil', this command reindents the current line
     only if point is at the left margin or in the line's indentation;
     otherwise, it inserts a tab (or the equivalent number of spaces,
     if `indent-tabs-mode' is `nil').

     Any other value (not `nil' or `t') means always reindent the line,
     and also insert a tab if within a comment, a string, or a
     preprocessor directive.

`C-u <TAB>'
     Reindent the current line according to its syntax; also rigidly
     reindent any other lines of the expression that starts on the
     current line.  *Note Multi-line Indent::.

   To reindent the whole current buffer, type `C-x h C-M-\'.  This
first selects the whole buffer as the region, then reindents that
region.

   To reindent the current block, use `C-M-u C-M-q'.  This moves to the
front of the block and then reindents it all.


File: emacs,  Node: Custom C Indent,  Prev: C Indent,  Up: Program Indent

Customizing C Indentation
-------------------------

   C mode and related modes use a simple yet flexible mechanism for
customizing indentation.  The mechanism works in two steps: first it
classifies the line syntactically according to its contents and context;
second, it associates each kind of syntactic construct with an
indentation offset which you can customize.

* Menu:

* Syntactic Analysis::
* Indentation Calculation::
* Changing Indent Style::
* Syntactic Symbols::
* Variables for C Indent::
* C Indent Styles::


File: emacs,  Node: Syntactic Analysis,  Next: Indentation Calculation,  Up: Custom C Indent

Step 1--Syntactic Analysis
..........................

   In the first step, the C indentation mechanism looks at the line you
are currently indenting and determines the syntactic components of the
construct on that line.  It builds a list of these syntactic components,
where each component on the list contains a "syntactic symbol" and a
relative buffer position.  Syntactic symbols describe grammatical
elements, for example `statement' and `substatement'; others describe
locations amidst grammatical elements, for example `class-open' and
`knr-argdecl'.

   Conceptually, a line of C code is always indented relative to the
indentation of some line higher up in the buffer.  This is represented
by the relative buffer positions in the syntactic component list.

   Here is an example.  Suppose we have the following code in a C++ mode
buffer (the line numbers don't actually appear in the buffer):

     1: void swap (int& a, int& b)
     2: {
     3:   int tmp = a;
     4:   a = b;
     5:   b = tmp;
     6: }

   If you type `C-c C-s' (which runs the command
`c-show-syntactic-information') on line 4, it shows the result of the
indentation mechanism for that line:

     ((statement . 32))

   This indicates that the line is a statement and it is indented
relative to buffer position 32, which happens to be the `i' in `int' on
line 3.  If you move the cursor to line 3 and type `C-c C-s', it
displays this:

     ((defun-block-intro . 28))

   This indicates that the `int' line is the first statement in a
block, and is indented relative to buffer position 28, which is the
brace just after the function header.

Here is another example:

     1: int add (int val, int incr, int doit)
     2: {
     3:   if (doit)
     4:     {
     5:       return (val + incr);
     6:     }
     7:   return (val);
     8: }

Typing `C-c C-s' on line 4 displays this:

     ((substatement-open . 43))

   This says that the brace *opens* a substatement block.  By the way,
a "substatement" indicates the line after an `if', `else', `while',
`do', `switch', and `for' statements.

   Within the C indentation commands, after a line has been analyzed
syntactically for indentation, the variable `c-syntactic-context'
contains a list that describes the results.  Each element in this list
is a a "syntactic component": a cons cell containing a syntactic symbol
and (optionally) its corresponding buffer position.  There may be
several elements in a component list; typically only one element has a
buffer position.


File: emacs,  Node: Indentation Calculation,  Next: Changing Indent Style,  Prev: Syntactic Analysis,  Up: Custom C Indent

Step 2--Indentation Calculation
...............................

   The C indentation mechanism calculates the indentation for the
current line using the list of syntactic components,
`c-syntactic-context', derived from syntactic analysis.  Each component
is a cons cell that contains a syntactic symbol and may also contain a
buffer position.

   Each component contributes to the final total indentation of the line
in two ways.  First, the syntactic symbol identifies an element of
`c-offsets-alist', which is an association list mapping syntactic
symbols into indentation offsets.  Each syntactic symbol's offset adds
to the total indentation.  Second, if the component includes a buffer
position, the column number of that position adds to the indentation.
All these offsets and column numbers, added together, give the total
indentation.

   The following examples demonstrate the workings of the C indentation
mechanism:

     1: void swap (int& a, int& b)
     2: {
     3:   int tmp = a;
     4:   a = b;
     5:   b = tmp;
     6: }

   Suppose that point is on line 3 and you type <TAB> to reindent the
line.  As explained above (*note Syntactic Analysis::.), the syntactic
component list for that line is:

     ((defun-block-intro . 28))

   In this case, the indentation calculation first looks up
`defun-block-intro' in the `c-offsets-alist' alist.  Suppose that it
finds the integer 2; it adds this to the running total (initialized to
zero), yielding a updated total indentation of 2 spaces.

   The next step is to find the column number of buffer position 28.
Since the brace at buffer position 28 is in column zero, this adds 0 to
the running total.  Since this line has only one syntactic component,
the total indentation for the line is 2 spaces.

     1: int add (int val, int incr, int doit)
     2: {
     3:   if (doit)
     4:     {
     5:       return(val + incr);
     6:     }
     7:   return(val);
     8: }

   If you type <TAB> on line 4, the same process is performed, but with
different data.  The syntactic component list for this line is:

     ((substatement-open . 43))

   Here, the indentation calculation's first job is to look up the
symbol `substatement-open' in `c-offsets-alist'.  Let's assume that the
offset for this symbol is 2.  At this point the running total is 2 (0 +
2 = 2).  Then it adds the column number of buffer position 43, which is
the `i' in `if' on line 3.  This character is in column 2 on that line.
Adding this yields a total indentation of 4 spaces.

   If a syntactic symbol in the analysis of a line does not appear in
`c-offsets-alist', it is ignored; if in addition the variable
`c-strict-syntax-p' is non-`nil', it is an error.


File: emacs,  Node: Changing Indent Style,  Next: Syntactic Symbols,  Prev: Indentation Calculation,  Up: Custom C Indent

Changing Indentation Style
..........................

   There are two ways to customize the indentation style for the C
modes.  First, you can select one of several predefined styles, each of
which specifies offsets for all the syntactic symbols.  For more
flexibility, you can customize the handling of individual syntactic
symbols.  *Note Syntactic Symbols::, for a list of all defined
syntactic symbols.

`M-x c-set-style <RET> STYLE <RET>'
     Select predefined indentation style STYLE.  Type `?' when entering
     STYLE to see a list of supported styles; to find out what a style
     looks like, select it and reindent some C code.

`C-c C-o SYMBOL <RET> OFFSET <RET>'
     Set the indentation offset for syntactic symbol SYMBOL
     (`c-set-offset').  The second argument OFFSET specifies the new
     indentation offset.

   The `c-offsets-alist' variable controls the amount of indentation to
give to each syntactic symbol.  Its value is an association list, and
each element of the list has the form `(SYNTACTIC-SYMBOL . OFFSET)'.
By changing the offsets for various syntactic symbols, you can
customize indentation in fine detail.  To change this alist, use
`c-set-offset' (see below).

   Each offset value in `c-offsets-alist' can be an integer, a function
or variable name, or one of the following symbols: `+', `-', `++', or
`--', indicating positive or negative multiples of the variable
`c-basic-offset'.  Thus, if you want to change the levels of
indentation to be 3 spaces instead of 2 spaces, set `c-basic-offset' to
3.

   Using a function as the offset value provides the ultimate
flexibility in customizing indentation.  The function is called with a
single argument containing the `cons' of the syntactic symbol and the
relative indent point.  The function should return an integer offset.

   The command `C-c C-o' (`c-set-offset') is the easiest way to set
offsets, both interactively or in your `~/.emacs' file.  First specify
the syntactic symbol, then the offset you want.  *Note Syntactic
Symbols::, for a list of valid syntactic symbols and their meanings.


File: emacs,  Node: Syntactic Symbols,  Next: Variables for C Indent,  Prev: Changing Indent Style,  Up: Custom C Indent

Syntactic Symbols
.................

   Here is a table of valid syntactic symbols for C mode indentation,
with their syntactic meanings.  Normally, most of these symbols are
assigned offsets in `c-offsets-alist'.

`string'
     Inside a multi-line string.

`c'
     Inside a multi-line C style block comment.

`defun-open'
     On a brace that opens a function definition.

`defun-close'
     On a brace that closes a function definition.

`defun-block-intro'
     In the first line in a top-level defun.

`class-open'
     On a brace that opens a class definition.

`class-close'
     On a brace that closes a class definition.

`inline-open'
     On a brace that opens an in-class inline method.

`inline-close'
     On a brace that closes an in-class inline method.

`extern-lang-open'
     On a brace that opens an external language block.

`extern-lang-close'
     On a brace that closes an external language block.

`func-decl-cont'
     The region between a function definition's argument list and the
     defun opening brace (excluding K&R function definitions).  In C,
     you cannot put anything but whitespace and comments between them;
     in C++ and Java, `throws' declarations and other things can appear
     in this context.

`knr-argdecl-intro'
     On the first line of a K&R C argument declaration.

`knr-argdecl'
     In one of the subsequent lines in a K&R C argument declaration.

`topmost-intro'
     On the first line in a topmost construct definition.

`topmost-intro-cont'
     On the topmost definition continuation lines.

`member-init-intro'
     On the first line in a member initialization list.

`member-init-cont'
     On one of the subsequent member initialization list lines.

`inher-intro'
     On the first line of a multiple inheritance list.

`inher-cont'
     On one of the subsequent multiple inheritance lines.

`block-open'
     On a statement block open brace.

`block-close'
     On a statement block close brace.

`brace-list-open'
     On the opening brace of an `enum' or `static' array list.

`brace-list-close'
     On the closing brace of an `enum' or `static' array list.

`brace-list-intro'
     On the first line in an `enum' or `static' array list.

`brace-list-entry'
     On one of the subsequent lines in an `enum' or `static' array list.

`statement'
     On an ordinary statement.

`statement-cont'
     On a continuation line of a statement.

`statement-block-intro'
     On the first line in a new statement block.

`statement-case-intro'
     On the first line in a `case' "block."

`statement-case-open'
     On the first line in a `case' block starting with brace.

`substatement'
     On the first line after an `if', `while', `for', `do', or `else'.

`substatement-open'
     On the brace that opens a substatement block.

`case-label'
     On a `case' or `default' label.

`access-label'
     On a C++ `private', `protected', or `public' access label.

`label'
     On any ordinary label.

`do-while-closure'
     On the `while' that ends a `do'-`while' construct.

`else-clause'
     On the `else' of an `if'-`else' construct.

`comment-intro'
     On a line containing only a comment introduction.

`arglist-intro'
     On the first line in an argument list.

`arglist-cont'
     On one of the subsequent argument list lines when no arguments
     follow on the same line as the arglist opening parenthesis.

`arglist-cont-nonempty'
     On one of the subsequent argument list lines when at least one
     argument follows on the same line as the arglist opening
     parenthesis.

`arglist-close'
     On the closing parenthesis of an argument list.

`stream-op'
     On one of the lines continuing a stream operator construct.

`inclass'
     On a construct that is nested inside a class definition.

`inextern-lang'
     On a construct that is nested inside an external language block.

`cpp-macro'
     On the start of a cpp macro.

`friend'
     On a C++ `friend' declaration.

`objc-method-intro'
     On the first line of an Objective-C method definition.

`objc-method-args-cont'
     On one of the lines continuing an Objective-C method definition.

`objc-method-call-cont'
     On one of the lines continuing an Objective-C method call.


File: emacs,  Node: Variables for C Indent,  Next: C Indent Styles,  Prev: Syntactic Symbols,  Up: Custom C Indent

Variables for C Indentation
...........................

   This section describes additional variables which control the
indentation behavior of C mode and related mode.

`c-offsets-alist'
     Association list of syntactic symbols and their indentation
     offsets.  You should not set this directly, only with
     `c-set-offset'.  *Note Changing Indent Style::, for details.

`c-style-alist'
     Variable for defining indentation styles; see below.

`c-basic-offset'
     Amount of basic offset used by `+' and `-' symbols in
     `c-offsets-alist'.

`c-special-indent-hook'
     Hook for user-defined special indentation adjustments.  This hook
     is called after a line is indented by C mode and related modes.

   The variable `c-style-alist' specifies the predefined indentation
styles.  Each element has form `(NAME VARIABLE-SETTING...)', where NAME
is the name of the style.  Each VARIABLE-SETTING has the form `(VARIABLE
. VALUE)'; VARIABLE is one of the customization variables used by C
mode, and VALUE is the value for that variable when using the selected
style.

   When VARIABLE is `c-offsets-alist', that is a special case: VALUE is
appended to the front of the value of `c-offsets-alist' instead of
replacing that value outright.  Therefore, it is not necessary for
VALUE to specify each and every syntactic symbol--only those for which
the style differs from the default.

   The indentation of lines containing only comments is also affected by
the variable `c-comment-only-line-offset' (*note Comments in C::.).


File: emacs,  Node: C Indent Styles,  Prev: Variables for C Indent,  Up: Custom C Indent

C Indentation Styles
....................

   A "C style" is a collection of indentation style customizations.
Emacs comes with several predefined indentation styles for C code
including `gnu', `k&r', `bsd', `stroustrup', `linux', `python', `java',
`whitesmith', `ellemtel', and `cc-mode'.  The default style is `gnu'.

   To choose the style you want, use the command `M-x c-set-style'.
Specify a style name as an argument (case is not significant in C style
names).  The chosen style only affects newly visited buffers, not those
you are already editing.

   To define a new C indentation style, call the function `c-add-style':

     (c-add-style NAME VALUES USE-NOW)

Here NAME is the name of the new style (a string), and VALUES is an
alist whose elements have the form `(VARIABLE . VALUE)'.  The variables
you specify should be among those documented in *Note Variables for C
Indent::.

   If USE-NOW is non-`nil', `c-add-style' switches to the new style
after defining it.


File: emacs,  Node: Matching,  Next: Comments,  Prev: Program Indent,  Up: Programs

Automatic Display Of Matching Parentheses
=========================================

   The Emacs parenthesis-matching feature is designed to show
automatically how parentheses match in the text.  Whenever you type a
self-inserting character that is a closing delimiter, the cursor moves
momentarily to the location of the matching opening delimiter, provided
that is on the screen.  If it is not on the screen, some text near it is
displayed in the echo area.  Either way, you can tell what grouping is
being closed off.

   In Lisp, automatic matching applies only to parentheses.  In C, it
applies to braces and brackets too.  Emacs knows which characters to
regard as matching delimiters based on the syntax table, which is set
by the major mode.  *Note Syntax::.

   If the opening delimiter and closing delimiter are mismatched--such
as in `[x)'--a warning message is displayed in the echo area.  The
correct matches are specified in the syntax table.

   Three variables control parenthesis match display.
`blink-matching-paren' turns the feature on or off; `nil' turns it off,
but the default is `t' to turn match display on.
`blink-matching-delay' says how many seconds to wait; the default is 1,
but on some systems it is useful to specify a fraction of a second.
`blink-matching-paren-distance' specifies how many characters back to
search to find the matching opening delimiter.  If the match is not
found in that far, scanning stops, and nothing is displayed.  This is
to prevent scanning for the matching delimiter from wasting lots of
time when there is no match.  The default is 12,000.

   When using X Windows, you can request a more powerful alternative
kind of automatic parenthesis matching by enabling Show Paren mode.
This mode turns off the usual kind of matching parenthesis display and
instead uses highlighting to show what matches.  Whenever point is after
a close parenthesis, the close parenthesis and its matching open
parenthesis are both highlighted; otherwise, if point is before an open
parenthesis, the matching close parenthesis is highlighted.  (There is
no need to highlight the open parenthesis after point because the cursor
appears on top of that character.)  Use the command `M-x
show-paren-mode' to enable or disable this mode.


File: emacs,  Node: Comments,  Next: Balanced Editing,  Prev: Matching,  Up: Programs

Manipulating Comments
=====================

   Because comments are such an important part of programming, Emacs
provides special commands for editing and inserting comments.

* Menu:

* Comment Commands::
* Multi-Line Comments::
* Options for Comments::


File: emacs,  Node: Comment Commands,  Next: Multi-Line Comments,  Up: Comments

Comment Commands
----------------

   The comment commands insert, kill and align comments.

`M-;'
     Insert or align comment (`indent-for-comment').

`C-x ;'
     Set comment column (`set-comment-column').

`C-u - C-x ;'
     Kill comment on current line (`kill-comment').

`C-M-j'
     Like <RET> followed by inserting and aligning a comment
     (`indent-new-comment-line').

`M-x comment-region'
     Add or remove comment delimiters on all the lines in the region.

   The command that creates a comment is `M-;' (`indent-for-comment').
If there is no comment already on the line, a new comment is created,
aligned at a specific column called the "comment column".  The comment
is created by inserting the string Emacs thinks comments should start
with (the value of `comment-start'; see below).  Point is left after
that string.  If the text of the line extends past the comment column,
then the indentation is done to a suitable boundary (usually, at least
one space is inserted).  If the major mode has specified a string to
terminate comments, that is inserted after point, to keep the syntax
valid.

   `M-;' can also be used to align an existing comment.  If a line
already contains the string that starts comments, then `M-;' just moves
point after it and reindents it to the conventional place.  Exception:
comments starting in column 0 are not moved.

   Some major modes have special rules for indenting certain kinds of
comments in certain contexts.  For example, in Lisp code, comments which
start with two semicolons are indented as if they were lines of code,
instead of at the comment column.  Comments which start with three
semicolons are supposed to start at the left margin.  Emacs understands
these conventions by indenting a double-semicolon comment using <TAB>,
and by not changing the indentation of a triple-semicolon comment at
all.

     ;; This function is just an example
     ;;; Here either two or three semicolons are appropriate.
     (defun foo (x)
     ;;; And now, the first part of the function:
       ;; The following line adds one.
       (1+ x))           ; This line adds one.

   In C code, a comment preceded on its line by nothing but whitespace
is indented like a line of code.

   Even when an existing comment is properly aligned, `M-;' is still
useful for moving directly to the start of the comment.

   `C-u - C-x ;' (`kill-comment') kills the comment on the current line,
if there is one.  The indentation before the start of the comment is
killed as well.  If there does not appear to be a comment in the line,
nothing is done.  To reinsert the comment on another line, move to the
end of that line, do `C-y', and then do `M-;' to realign it.  Note that
`C-u - C-x ;' is not a distinct key; it is `C-x ;'
(`set-comment-column') with a negative argument.  That command is
programmed so that when it receives a negative argument it calls
`kill-comment'.  However, `kill-comment' is a valid command which you
could bind directly to a key if you wanted to.


File: emacs,  Node: Multi-Line Comments,  Next: Options for Comments,  Prev: Comment Commands,  Up: Comments

Multiple Lines of Comments
--------------------------

   If you are typing a comment and wish to continue it on another line,
you can use the command `C-M-j' (`indent-new-comment-line').  This
terminates the comment you are typing, creates a new blank line
afterward, and begins a new comment indented under the old one.  When
Auto Fill mode is on, going past the fill column while typing a comment
causes the comment to be continued in just this fashion.  If point is
not at the end of the line when `C-M-j' is typed, the text on the rest
of the line becomes part of the new comment line.

   To turn existing lines into comment lines, use the `M-x
comment-region' command.  It adds comment delimiters to the lines that
start in the region, thus commenting them out.  With a negative
argument, it does the opposite--it deletes comment delimiters from the
lines in the region.

   With a positive argument, `comment-region' duplicates the last
character of the comment start sequence it adds; the argument specifies
how many copies of the character to insert.  Thus, in Lisp mode, `C-u 2
M-x comment-region' adds `;;' to each line.  Duplicating the comment
delimiter is a way of calling attention to the comment.  It can also
affect how the comment is indented.  In Lisp, for proper indentation,
you should use an argument of two, if between defuns, and three, if
within a defun.

   The variable `comment-padding' specifies how many spaces
`comment-region' should insert on each line between the comment
delimiter and the line's original text.  The default is 1.


File: emacs,  Node: Options for Comments,  Prev: Multi-Line Comments,  Up: Comments

Options Controlling Comments
----------------------------

   The comment column is stored in the variable `comment-column'.  You
can set it to a number explicitly.  Alternatively, the command `C-x ;'
(`set-comment-column') sets the comment column to the column point is
at.  `C-u C-x ;' sets the comment column to match the last comment
before point in the buffer, and then does a `M-;' to align the current
line's comment under the previous one.  Note that `C-u - C-x ;' runs
the function `kill-comment' as described above.

   The variable `comment-column' is per-buffer: setting the variable in
the normal fashion affects only the current buffer, but there is a
default value which you can change with `setq-default'.  *Note
Locals::.  Many major modes initialize this variable for the current
buffer.

   The comment commands recognize comments based on the regular
expression that is the value of the variable `comment-start-skip'.
Make sure this regexp does not match the null string.  It may match more
than the comment starting delimiter in the strictest sense of the word;
for example, in C mode the value of the variable is `"/\\*+ *"', which
matches extra stars and spaces after the `/*' itself.  (Note that `\\'
is needed in Lisp syntax to include a `\' in the string, which is
needed to deny the first star its special meaning in regexp syntax.
*Note Regexps::.)

   When a comment command makes a new comment, it inserts the value of
`comment-start' to begin it.  The value of `comment-end' is inserted
after point, so that it will follow the text that you will insert into
the comment.  In C mode, `comment-start' has the value `"/* "' and
`comment-end' has the value `" */"'.

   The variable `comment-multi-line' controls how `C-M-j'
(`indent-new-comment-line') behaves when used inside a comment.  If
`comment-multi-line' is `nil', as it normally is, then the comment on
the starting line is terminated and a new comment is started on the new
following line.  If `comment-multi-line' is not `nil', then the new
following line is set up as part of the same comment that was found on
the starting line.  This is done by not inserting a terminator on the
old line, and not inserting a starter on the new line.  In languages
where multi-line comments work, the choice of value for this variable
is a matter of taste.

   The variable `comment-indent-function' should contain a function
that will be called to compute the indentation for a newly inserted
comment or for aligning an existing comment.  It is set differently by
various major modes.  The function is called with no arguments, but with
point at the beginning of the comment, or at the end of a line if a new
comment is to be inserted.  It should return the column in which the
comment ought to start.  For example, in Lisp mode, the indent hook
function bases its decision on how many semicolons begin an existing
comment, and on the code in the preceding lines.

