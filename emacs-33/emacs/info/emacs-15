This is Info file ../info/emacs, produced by Makeinfo version 1.68 from
the input file emacs.texi.

   This is the thirteenth edition of the `GNU Emacs Manual', updated
for Emacs version 20.3

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307 USA

   Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998
Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.


File: emacs,  Node: Electric C,  Next: Hungry Delete,  Prev: Motion in C,  Up: C/Java Modes

Electric C Characters
---------------------

   In C mode and related modes, certain printing characters are
"electric"--in addition to inserting themselves, they also reindent the
current line and may insert newlines.  This feature is controlled by
the variable `c-auto-newline'.  The "electric" characters are `{', `}',
`:', `#', `;', `,', `<', `>', `/' and `*'.

   Electric characters insert newlines only when the "auto-newline"
feature is enabled (indicated by `/a' in the mode line after the mode
name).  This feature is controlled by the variable `c-auto-newline'.
You can turn this feature on or off with the command `C-c C-a':

`C-c C-a'
     Toggle the auto-newline feature (`c-toggle-auto-state').  With a
     prefix argument, this command turns the auto-newline feature on if
     the argument is positive, and off if it is negative.

   The colon character is electric because that is appropriate for a
single colon.  But when you want to insert a double colon in C++, the
electric behavior of colon is inconvenient.  You can insert a double
colon with no reindentation or newlines by typing `C-c :':

`C-c :'
     Insert a double colon scope operator at point, without reindenting
     the line or adding any newlines (`c-scope-operator').

   The electric `#' key reindents the line if it appears to be the
beginning of a preprocessor directive.  This happens when the value of
`c-electric-pound-behavior' is `(alignleft)'.  You can turn this
feature off by setting `c-electric-pound-behavior' to `nil'.

   The variable `c-hanging-braces-alist' controls the insertion of
newlines before and after inserted braces.  It is an association list
with elements of the following form: `(SYNTACTIC-SYMBOL . NL-LIST)'.
Most of the syntactic symbols that appear in `c-offsets-alist' are
meaningful here as well.

   The list NL-LIST may contain either of the symbols `before' or
`after', or both; or it may be `nil'.  When a brace is inserted, the
syntactic context it defines is looked up in `c-hanging-braces-alist';
if it is found, the NL-LIST is used to determine where newlines are
inserted: either before the brace, after, or both.  If not found, the
default is to insert a newline both before and after braces.

   The variable `c-hanging-colons-alist' controls the insertion of
newlines before and after inserted colons.  It is an association list
with elements of the following form: `(SYNTACTIC-SYMBOL . NL-LIST)'.
The list NL-LIST may contain either of the symbols `before' or `after',
or both; or it may be `nil'.

   When a colon is inserted, the syntactic symbol it defines is looked
up in this list, and if found, the NL-LIST is used to determine where
newlines are inserted: either before the brace, after, or both.  If the
syntactic symbol is not found in this list, no newlines are inserted.

   Electric characters can also delete newlines automatically when the
auto-newline feature is enabled.  This feature makes auto-newline more
acceptable, by deleting the newlines in the most common cases where you
do not want them.  Emacs can recognize several cases in which deleting a
newline might be desirable; by setting the variable `c-cleanup-list',
you can specify *which* of these cases that should happen.  The
variable's value is a list of symbols, each describing one case for
possible deletion of a newline.  Here are the meaningful symbols, and
their meanings:

`brace-else-brace'
     Clean up `} else {' constructs by placing the entire construct on
     a single line.  The clean-up occurs when you type the `{' after
     the `else', but only if there is nothing but white space between
     the braces and the `else'.

`brace-elseif-brace'
     Clean up `} else if (...) {' constructs by placing the entire
     construct on a single line.  The clean-up occurs when you type the
     `{', if there is nothing but white space between the `}' and `{'
     aside from the keywords and the `if'-condition.

`empty-defun-braces'
     Clean up empty defun braces by placing the braces on the same
     line.  Clean-up occurs when you type the closing brace.

`defun-close-semi'
     Clean up the semicolon after a `struct' or similar type
     declaration, by placing the semicolon on the same line as the
     closing brace.  Clean-up occurs when you type the semicolon.

`list-close-comma'
     Clean up commas following braces in array and aggregate
     initializers.  Clean-up occurs when you type the comma.

`scope-operator'
     Clean up double colons which may designate a C++ scope operator, by
     placing the colons together.  Clean-up occurs when you type the
     second colon, but only when the two colons are separated by
     nothing but whitespace.


File: emacs,  Node: Hungry Delete,  Next: Other C Commands,  Prev: Electric C,  Up: C/Java Modes

Hungry Delete Feature in C
--------------------------

   When the "hungry-delete" feature is enabled (indicated by `/h' or
`/ah' in the mode line after the mode name), a single <DEL> command
deletes all preceding whitespace, not just one space.  To turn this
feature on or off, use `C-c C-d':

`C-c C-d'
     Toggle the hungry-delete feature (`c-toggle-hungry-state').  With a
     prefix argument, this command turns the hungry-delete feature on
     if the argument is positive, and off if it is negative.

`C-c C-t'
     Toggle the auto-newline and hungry-delete features, both at once
     (`c-toggle-auto-hungry-state').

   The variable `c-hungry-delete-key' controls whether the
hungry-delete feature is enabled.


File: emacs,  Node: Other C Commands,  Next: Comments in C,  Prev: Hungry Delete,  Up: C/Java Modes

Other Commands for C Mode
-------------------------

`C-M-h'
     Put mark at the end of a function definition, and put point at the
     beginning (`c-mark-function').

`M-q'
     Fill a paragraph, handling C and C++ comments (`c-fill-paragraph').
     If any part of the current line is a comment or within a comment,
     this command fills the comment or the paragraph of it that point
     is in, preserving the comment indentation and comment delimiters.

`C-c C-e'
     Run the C preprocessor on the text in the region, and show the
     result, which includes the expansion of all the macro calls
     (`c-macro-expand').  The buffer text before the region is also
     included in preprocessing, for the sake of macros defined there,
     but the output from this part isn't shown.

     When you are debugging C code that uses macros, sometimes it is
     hard to figure out precisely how the macros expand.  With this
     command, you don't have to figure it out; you can see the
     expansions.

`C-c C-\'
     Insert or align `\' characters at the ends of the lines of the
     region (`c-backslash-region').  This is useful after writing or
     editing a C macro definition.

     If a line already ends in `\', this command adjusts the amount of
     whitespace before it.  Otherwise, it inserts a new `\'.  However,
     the last line in the region is treated specially; no `\' is
     inserted on that line, and any `\' there is deleted.

`M-x cpp-highlight-buffer'
     Highlight parts of the text according to its preprocessor
     conditionals.  This command displays another buffer named `*CPP
     Edit*', which serves as a graphic menu for selecting how to
     display particular kinds of conditionals and their contents.
     After changing various settings, click on `[A]pply these settings'
     (or go to that buffer and type `a') to rehighlight the C mode
     buffer accordingly.

`C-c C-s'
     Display the syntactic information about the current source line
     (`c-show-syntactic-information').  This is the information that
     directs how the line is indented.


File: emacs,  Node: Comments in C,  Prev: Other C Commands,  Up: C/Java Modes

Comments in C Modes
-------------------

   C mode and related modes use a number of variables for controlling
comment format.

`c-comment-only-line-offset'
     Extra offset for line which contains only the start of a comment.
     It can be either an integer or a cons cell of the form
     `(NON-ANCHORED-OFFSET . ANCHORED-OFFSET)', where
     NON-ANCHORED-OFFSET is the amount of offset given to
     non-column-zero anchored comment-only lines, and ANCHORED-OFFSET
     is the amount of offset to give column-zero anchored comment-only
     lines.  Just an integer as value is equivalent to `(VAL . 0)'.

`c-comment-start-regexp'
     This buffer-local variable specifies how to recognize the start of
     a comment.

`c-hanging-comment-ender-p'
     If this variable is `nil', `c-fill-paragraph' leaves the comment
     terminator of a block comment on a line by itself.  The default
     value is `t', which puts the comment-end delimiter `*/' at the end
     of the last line of the comment text.

`c-hanging-comment-starter-p'
     If this variable is `nil', `c-fill-paragraph' leaves the starting
     delimiter of a block comment on a line by itself.  The default
     value is `t', which puts the comment-start delimiter `/*' at the
     beginning of the first line of the comment text.


File: emacs,  Node: Fortran,  Next: Asm Mode,  Prev: C/Java Modes,  Up: Programs

Fortran Mode
============

   Fortran mode provides special motion commands for Fortran statements
and subprograms, and indentation commands that understand Fortran
conventions of nesting, line numbers and continuation statements.
Fortran mode has its own Auto Fill mode that breaks long lines into
proper Fortran continuation lines.

   Special commands for comments are provided because Fortran comments
are unlike those of other languages.  Built-in abbrevs optionally save
typing when you insert Fortran keywords.

   Use `M-x fortran-mode' to switch to this major mode.  This command
runs the hook `fortran-mode-hook' (*note Hooks::.).

* Menu:

* Motion: Fortran Motion.	 Moving point by statements or subprograms.
* Indent: Fortran Indent.	 Indentation commands for Fortran.
* Comments: Fortran Comments.	 Inserting and aligning comments.
* Autofill: Fortran Autofill.	 Auto fill minor mode for Fortran.
* Columns: Fortran Columns.	 Measuring columns for valid Fortran.
* Abbrev: Fortran Abbrev.	 Built-in abbrevs for Fortran keywords.
* Misc: Fortran Misc.            Other Fortran mode features.


File: emacs,  Node: Fortran Motion,  Next: Fortran Indent,  Up: Fortran

Motion Commands
---------------

   Fortran mode provides special commands to move by subprograms
(functions and subroutines) and by statements.  There is also a command
to put the region around one subprogram, convenient for killing it or
moving it.

`C-M-a'
     Move to beginning of subprogram
     (`beginning-of-fortran-subprogram').

`C-M-e'
     Move to end of subprogram (`end-of-fortran-subprogram').

`C-M-h'
     Put point at beginning of subprogram and mark at end
     (`mark-fortran-subprogram').

`C-c C-n'
     Move to beginning of current or next statement
     (`fortran-next-statement').

`C-c C-p'
     Move to beginning of current or previous statement
     (`fortran-previous-statement').


File: emacs,  Node: Fortran Indent,  Next: Fortran Comments,  Prev: Fortran Motion,  Up: Fortran

Fortran Indentation
-------------------

   Special commands and features are needed for indenting Fortran code
in order to make sure various syntactic entities (line numbers, comment
line indicators and continuation line flags) appear in the columns that
are required for standard Fortran.

* Menu:

* Commands: ForIndent Commands.  Commands for indenting Fortran.
* Contline: ForIndent Cont.      How continuation lines indent.
* Numbers:  ForIndent Num.       How line numbers auto-indent.
* Conv:     ForIndent Conv.      Conventions you must obey to avoid trouble.
* Vars:     ForIndent Vars.      Variables controlling Fortran indent style.


File: emacs,  Node: ForIndent Commands,  Next: ForIndent Cont,  Up: Fortran Indent

Fortran Indentation Commands
............................

`<TAB>'
     Indent the current line (`fortran-indent-line').

`C-j'
     Indent the current and start a new indented line
     (`fortran-indent-new-line').

`C-M-j'
     Break the current line and set up a continuation line.

`M-^'
     Join this line to the previous line.

`C-M-q'
     Indent all the lines of the subprogram point is in
     (`fortran-indent-subprogram').

   Fortran mode redefines <TAB> to reindent the current line for
Fortran (`fortran-indent-line').  This command indents line numbers and
continuation markers to their required columns, and independently
indents the body of the statement based on its nesting in the program.

   The key `C-j' runs the command `fortran-indent-new-line', which
reindents the current line then makes and indents a new line.  This
command is useful to reindent the closing statement of `do' loops and
other blocks before starting a new line.

   The key `C-M-q' runs `fortran-indent-subprogram', a command to
reindent all the lines of the Fortran subprogram (function or
subroutine) containing point.

   The key `C-M-j' runs `fortran-split-line', which splits a line in
the appropriate fashion for Fortran.  In a non-comment line, the second
half becomes a continuation line and is indented accordingly.  In a
comment line, both halves become separate comment lines.

   `M-^' runs the command `fortran-join-line', which is more or less
the inverse of `fortran-split-line'.  It joins the current line to the
previous line in a suitable way for Fortran code.


File: emacs,  Node: ForIndent Cont,  Next: ForIndent Num,  Prev: ForIndent Commands,  Up: Fortran Indent

Continuation Lines
..................

   Most modern Fortran compilers allow two ways of writing continuation
lines.  If the first non-space character on a line is in column 5, then
that line is a continuation of the previous line.  We call this "fixed
format".  (In GNU Emacs we always count columns from 0.)  The variable
`fortran-continuation-string' specifies what character to put on column
5.  A line that starts with a tab character followed by any digit
except `0' is also a continuation line.  We call this style of
continuation "tab format".

   Fortran mode can make either style of continuation line, but you
must specify which one you prefer.  The value of the variable
`indent-tabs-mode' controls the choice: `nil' for fixed format, and
non-`nil' for tab format.  You can tell which style is presently in
effect by the presence or absence of the string `Tab' in the mode line.

   If the text on a line starts with the conventional Fortran
continuation marker `$', or if it begins with any non-whitespace
character in column 5, Fortran mode treats it as a continuation line.
When you indent a continuation line with <TAB>, it converts the line to
the current continuation style.  When you split a Fortran statement
with `C-M-j', the continuation marker on the newline is created
according to the continuation style.

   The setting of continuation style affects several other aspects of
editing in Fortran mode.  In fixed format mode, the minimum column
number for the body of a statement is 6.  Lines inside of Fortran
blocks that are indented to larger column numbers always use only the
space character for whitespace.  In tab format mode, the minimum column
number for the statement body is 8, and the whitespace before column 8
must always consist of one tab character.

   When you enter Fortran mode for an existing file, it tries to deduce
the proper continuation style automatically from the file contents.
The first line that begins with either a tab character or six spaces
determines the choice.  The variable `fortran-analyze-depth' specifies
how many lines to consider (at the beginning of the file); if none of
those lines indicates a style, then the variable
`fortran-tab-mode-default' specifies the style.  If it is `nil', that
specifies fixed format, and non-`nil' specifies tab format.


File: emacs,  Node: ForIndent Num,  Next: ForIndent Conv,  Prev: ForIndent Cont,  Up: Fortran Indent

Line Numbers
............

   If a number is the first non-whitespace in the line, Fortran
indentation assumes it is a line number and moves it to columns 0
through 4.  (Columns always count from 0 in GNU Emacs.)

   Line numbers of four digits or less are normally indented one space.
The variable `fortran-line-number-indent' controls this; it specifies
the maximum indentation a line number can have.  Line numbers are
indented to right-justify them to end in column 4 unless that would
require more than this maximum indentation.  The default value of the
variable is 1.

   Simply inserting a line number is enough to indent it according to
these rules.  As each digit is inserted, the indentation is recomputed.
To turn off this feature, set the variable
`fortran-electric-line-number' to `nil'.  Then inserting line numbers
is like inserting anything else.


File: emacs,  Node: ForIndent Conv,  Next: ForIndent Vars,  Prev: ForIndent Num,  Up: Fortran Indent

Syntactic Conventions
.....................

   Fortran mode assumes that you follow certain conventions that
simplify the task of understanding a Fortran program well enough to
indent it properly:

   * Two nested `do' loops never share a `continue' statement.

   * Fortran keywords such as `if', `else', `then', `do' and others are
     written without embedded whitespace or line breaks.

     Fortran compilers generally ignore whitespace outside of string
     constants, but Fortran mode does not recognize these keywords if
     they are not contiguous.  Constructs such as `else if' or `end do'
     are acceptable, but the second word should be on the same line as
     the first and not on a continuation line.

If you fail to follow these conventions, the indentation commands may
indent some lines unaesthetically.  However, a correct Fortran program
retains its meaning when reindented even if the conventions are not
followed.


File: emacs,  Node: ForIndent Vars,  Prev: ForIndent Conv,  Up: Fortran Indent

Variables for Fortran Indentation
.................................

   Several additional variables control how Fortran indentation works:

`fortran-do-indent'
     Extra indentation within each level of `do' statement (default 3).

`fortran-if-indent'
     Extra indentation within each level of `if' statement (default 3).
     This value is also used for extra indentation within each level of
     the Fortran 90 `where' statement.

`fortran-structure-indent'
     Extra indentation within each level of `structure', `union', or
     `map' statements (default 3).

`fortran-continuation-indent'
     Extra indentation for bodies of continuation lines (default 5).

`fortran-check-all-num-for-matching-do'
     If this is `nil', indentation assumes that each `do' statement
     ends on a `continue' statement.  Therefore, when computing
     indentation for a statement other than `continue', it can save time
     by not checking for a `do' statement ending there.  If this is
     non-`nil', indenting any numbered statement must check for a `do'
     that ends there.  The default is `nil'.

`fortran-blink-matching-if'
     If this is `t', indenting an `endif' statement moves the cursor
     momentarily to the matching `if' statement to show where it is.
     The default is `nil'.

`fortran-minimum-statement-indent-fixed'
     Minimum indentation for fortran statements when using fixed format
     continuation line style.  Statement bodies are never indented less
     than this much.  The default is 6.

`fortran-minimum-statement-indent-tab'
     Minimum indentation for fortran statements for tab format
     continuation line style.  Statement bodies are never indented less
     than this much.  The default is 8.


File: emacs,  Node: Fortran Comments,  Next: Fortran Autofill,  Prev: Fortran Indent,  Up: Fortran

Fortran Comments
----------------

   The usual Emacs comment commands assume that a comment can follow a
line of code.  In Fortran, the standard comment syntax requires an
entire line to be just a comment.  Therefore, Fortran mode replaces the
standard Emacs comment commands and defines some new variables.

   Fortran mode can also handle a nonstandard comment syntax where
comments start with `!' and can follow other text.  Because only some
Fortran compilers accept this syntax, Fortran mode will not insert such
comments unless you have said in advance to do so.  To do this, set the
variable `comment-start' to `"!"' (*note Variables::.).

`M-;'
     Align comment or insert new comment (`fortran-comment-indent').

`C-x ;'
     Applies to nonstandard `!' comments only.

`C-c ;'
     Turn all lines of the region into comments, or (with argument)
     turn them back into real code (`fortran-comment-region').

   `M-;' in Fortran mode is redefined as the command
`fortran-comment-indent'.  Like the usual `M-;' command, this
recognizes any kind of existing comment and aligns its text
appropriately; if there is no existing comment, a comment is inserted
and aligned.  But inserting and aligning comments are not the same in
Fortran mode as in other modes.

   When a new comment must be inserted, if the current line is blank, a
full-line comment is inserted.  On a non-blank line, a nonstandard `!'
comment is inserted if you have said you want to use them.  Otherwise a
full-line comment is inserted on a new line before the current line.

   Nonstandard `!' comments are aligned like comments in other
languages, but full-line comments are different.  In a standard
full-line comment, the comment delimiter itself must always appear in
column zero.  What can be aligned is the text within the comment.  You
can choose from three styles of alignment by setting the variable
`fortran-comment-indent-style' to one of these values:

`fixed'
     Align the text at a fixed column, which is the sum of
     `fortran-comment-line-extra-indent' and the minimum statement
     indentation.  This is the default.

     The minimum statement indentation is
     `fortran-minimum-statement-indent-fixed' for fixed format
     continuation line style and `fortran-minimum-statement-indent-tab'
     for tab format style.

`relative'
     Align the text as if it were a line of code, but with an additional
     `fortran-comment-line-extra-indent' columns of indentation.

`nil'
     Don't move text in full-line columns automatically at all.

   In addition, you can specify the character to be used to indent
within full-line comments by setting the variable
`fortran-comment-indent-char' to the single-character string you want
to use.

   Fortran mode introduces two variables `comment-line-start' and
`comment-line-start-skip', which play for full-line comments the same
roles played by `comment-start' and `comment-start-skip' for ordinary
text-following comments.  Normally these are set properly by Fortran
mode, so you do not need to change them.

   The normal Emacs comment command `C-x ;' has not been redefined.  If
you use `!' comments, this command can be used with them.  Otherwise it
is useless in Fortran mode.

   The command `C-c ;' (`fortran-comment-region') turns all the lines
of the region into comments by inserting the string `C$$$' at the front
of each one.  With a numeric argument, it turns the region back into
live code by deleting `C$$$' from the front of each line in it.  The
string used for these comments can be controlled by setting the
variable `fortran-comment-region'.  Note that here we have an example
of a command and a variable with the same name; these two uses of the
name never conflict because in Lisp and in Emacs it is always clear
from the context which one is meant.


File: emacs,  Node: Fortran Autofill,  Next: Fortran Columns,  Prev: Fortran Comments,  Up: Fortran

Fortran Auto Fill Mode
----------------------

   Fortran Auto Fill mode is a minor mode which automatically splits
Fortran statements as you insert them when they become too wide.
Splitting a statement involves making continuation lines using
`fortran-continuation-string' (*Note ForIndent Cont::).  This splitting
happens when you type <SPC>, <RET>, or <TAB>, and also in the Fortran
indentation commands.

   `M-x fortran-auto-fill-mode' turns Fortran Auto Fill mode on if it
was off, or off if it was on.  This command works the same as `M-x
auto-fill-mode' does for normal Auto Fill mode (*note Filling::.).  A
positive numeric argument turns Fortran Auto Fill mode on, and a
negative argument turns it off.  You can see when Fortran Auto Fill mode
is in effect by the presence of the word `Fill' in the mode line,
inside the parentheses.  Fortran Auto Fill mode is a minor mode, turned
on or off for each buffer individually.  *Note Minor Modes::.

   Fortran Auto Fill mode breaks lines at spaces or delimiters when the
lines get longer than the desired width (the value of `fill-column').
The delimiters that Fortran Auto Fill mode may break at are `,', `'',
`+', `-', `/', `*', `=', and `)'.  The line break comes after the
delimiter if the variable `fortran-break-before-delimiters' is `nil'.
Otherwise (and by default), the break comes before the delimiter.

   By default, Fortran Auto Fill mode is not enabled.  If you want this
feature turned on permanently, add a hook function to
`fortran-mode-hook' to execute `(fortran-auto-fill-mode 1)'.  *Note
Hooks::.


File: emacs,  Node: Fortran Columns,  Next: Fortran Abbrev,  Prev: Fortran Autofill,  Up: Fortran

Checking Columns in Fortran
---------------------------

`C-c C-r'
     Display a "column ruler" momentarily above the current line
     (`fortran-column-ruler').

`C-c C-w'
     Split the current window horizontally temporarily so that it is 72
     columns wide.  This may help you avoid making lines longer than the
     72-character limit that some Fortran compilers impose
     (`fortran-window-create-momentarily').

   The command `C-c C-r' (`fortran-column-ruler') shows a column ruler
momentarily above the current line.  The comment ruler is two lines of
text that show you the locations of columns with special significance in
Fortran programs.  Square brackets show the limits of the columns for
line numbers, and curly brackets show the limits of the columns for the
statement body.  Column numbers appear above them.

   Note that the column numbers count from zero, as always in GNU Emacs.
As a result, the numbers may be one less than those you are familiar
with; but the positions they indicate in the line are standard for
Fortran.

   The text used to display the column ruler depends on the value of
the variable `indent-tabs-mode'.  If `indent-tabs-mode' is `nil', then
the value of the variable `fortran-column-ruler-fixed' is used as the
column ruler.  Otherwise, the variable `fortran-column-ruler-tab' is
displayed.  By changing these variables, you can change the column
ruler display.

   For even more help, use `C-c C-w' (`fortran-window-create'), a
command which splits the current window horizontally, making a window 72
columns wide.  By editing in this window you can immediately see when
you make a line too wide to be correct Fortran.


File: emacs,  Node: Fortran Abbrev,  Next: Fortran Misc,  Prev: Fortran Columns,  Up: Fortran

Fortran Keyword Abbrevs
-----------------------

   Fortran mode provides many built-in abbrevs for common keywords and
declarations.  These are the same sort of abbrev that you can define
yourself.  To use them, you must turn on Abbrev mode.  *Note Abbrevs::.

   The built-in abbrevs are unusual in one way: they all start with a
semicolon.  You cannot normally use semicolon in an abbrev, but Fortran
mode makes this possible by changing the syntax of semicolon to "word
constituent."

   For example, one built-in Fortran abbrev is `;c' for `continue'.  If
you insert `;c' and then insert a punctuation character such as a space
or a newline, the `;c' expands automatically to `continue', provided
Abbrev mode is enabled.

   Type `;?' or `;C-h' to display a list of all the built-in Fortran
abbrevs and what they stand for.


File: emacs,  Node: Fortran Misc,  Prev: Fortran Abbrev,  Up: Fortran

Other Fortran Mode Commands
---------------------------

`C-x n d'
     Narrow to the current Fortran subprogram.

   Fortran mode redefines the key `C-x n d' to run the command
`fortran-narrow-to-subprogram', which is the Fortran analogue of the
key's usual definition.  It narrows the buffer to the subprogram
containing point.


File: emacs,  Node: Asm Mode,  Prev: Fortran,  Up: Programs

Asm Mode
========

   Asm mode is a major mode for editing files of assembler code.  It
defines these commands:

`<TAB>'
     `tab-to-tab-stop'.

`C-j'
     Insert a newline and then indent using `tab-to-tab-stop'.

`:'
     Insert a colon and then remove the indentation from before the
     label preceding colon.  Then do `tab-to-tab-stop'.

`;'
     Insert or align a comment.

   The variable `asm-comment-char' specifies which character starts
comments in assembler syntax.


File: emacs,  Node: Building,  Next: Abbrevs,  Prev: Programs,  Up: Top

Compiling and Testing Programs
******************************

   The previous chapter discusses the Emacs commands that are useful for
making changes in programs.  This chapter deals with commands that
assist in the larger process of developing and maintaining programs.

* Menu:

* Compilation::         Compiling programs in languages other
                          than Lisp (C, Pascal, etc.).
* Grep Searching::      Running grep as if it were a compiler.
* Compilation Mode::    The mode for visiting compiler errors.
* Compilation Shell::   Customizing your shell properly
                          for use in the compilation buffer.
* Debuggers::	        Running symbolic debuggers for non-Lisp programs.
* Executing Lisp::      Various modes for editing Lisp programs,
                          with different facilities for running
                          the Lisp programs.
* Libraries: Lisp Libraries.      Creating Lisp programs to run in Emacs.
* Interaction: Lisp Interaction.  Executing Lisp in an Emacs buffer.
* Eval: Lisp Eval.      Executing a single Lisp expression in Emacs.
* External Lisp::         Communicating through Emacs with a separate Lisp.


File: emacs,  Node: Compilation,  Next: Grep Searching,  Up: Building

Running Compilations under Emacs
================================

   Emacs can run compilers for noninteractive languages such as C and
Fortran as inferior processes, feeding the error log into an Emacs
buffer.  It can also parse the error messages and show you the source
lines where compilation errors occurred.

`M-x compile'
     Run a compiler asynchronously under Emacs, with error messages to
     `*compilation*' buffer.

`M-x grep'
     Run `grep' asynchronously under Emacs, with matching lines listed
     in the buffer named `*grep*'.

`M-x grep-find'
     Run `grep' via `find', with user-specified arguments, and collect
     output in the buffer named `*grep*'.

`M-x kill-compilation'
`M-x kill-grep'
     Kill the running compilation or `grep' subprocess.

   To run `make' or another compilation command, do `M-x compile'.
This command reads a shell command line using the minibuffer, and then
executes the command in an inferior shell, putting output in the buffer
named `*compilation*'.  The current buffer's default directory is used
as the working directory for the execution of the command; normally,
therefore, the compilation happens in this directory.

   When the shell command line is read, the minibuffer appears
containing a default command line, which is the command you used the
last time you did `M-x compile'.  If you type just <RET>, the same
command line is used again.  For the first `M-x compile', the default is
`make -k'.  The default compilation command comes from the variable
`compile-command'; if the appropriate compilation command for a file is
something other than `make -k', it can be useful for the file to
specify a local value for `compile-command' (*note File Variables::.).

   Starting a compilation displays the buffer `*compilation*' in
another window but does not select it.  The buffer's mode line tells you
whether compilation is finished, with the word `run' or `exit' inside
the parentheses.  You do not have to keep this buffer visible;
compilation continues in any case.  While a compilation is going on, the
string `Compiling' appears in the mode lines of all windows.  When this
string disappears, the compilation is finished.

   If you want to watch the compilation transcript as it appears, switch
to the `*compilation*' buffer and move point to the end of the buffer.
When point is at the end, new compilation output is inserted above
point, which remains at the end.  If point is not at the end of the
buffer, it remains fixed while more compilation output is added at the
end of the buffer.

   If you set the variable `compilation-scroll-output' to a non-`nil'
value, then the compilation buffer always scrolls to follow output as
it comes in.

   To kill the compilation process, do `M-x kill-compilation'.  When
the compiler process terminates, the mode line of the `*compilation*'
buffer changes to say `signal' instead of `run'.  Starting a new
compilation also kills any running compilation, as only one can exist
at any time.  However, `M-x compile' asks for confirmation before
actually killing a compilation that is running.


File: emacs,  Node: Grep Searching,  Next: Compilation Mode,  Prev: Compilation,  Up: Building

Searching with Grep under Emacs
===============================

   Just as you can run a compiler from Emacs and then visit the lines
where there were compilation errors, you can also run `grep' and then
visit the lines on which matches were found.  This works by treating
the matches reported by `grep' as if they were "errors."

   To do this, type `M-x grep', then enter a command line that
specifies how to run `grep'.  Use the same arguments you would give
`grep' when running it normally: a `grep'-style regexp (usually in
single-quotes to quote the shell's special characters) followed by file
names, which may use wildcards.  The output from `grep' goes in the
`*grep*' buffer.  You can find the corresponding lines in the original
files using `C-x `' and <RET>, as with compilation errors.

   If you specify a prefix argument for `M-x grep', it figures out the
tag (*note Tags::.) around point, and puts that into the default `grep'
command.

   The command `M-x grep-find' is similar to `M-x grep', but it
supplies a different initial default for the command--one that runs
both `find' and `grep', so as to search every file in a directory tree.
See also the `find-grep-dired' command, in *Note Dired and Find::.


File: emacs,  Node: Compilation Mode,  Next: Compilation Shell,  Prev: Grep Searching,  Up: Building

Compilation Mode
================

   The `*compilation*' buffer uses a special major mode, Compilation
mode, whose main feature is to provide a convenient way to look at the
source line where the error happened.

`C-x `'
     Visit the locus of the next compiler error message or `grep' match.

`<RET>'
     Visit the locus of the error message that point is on.  This
     command is used in the compilation buffer.

`Mouse-2'
     Visit the locus of the error message that you click on.

   You can visit the source for any particular error message by moving
point in `*compilation*' to that error message and typing <RET>
(`compile-goto-error').  Or click `Mouse-2' on the error message; you
need not switch to the `*compilation*' buffer first.

   To parse the compiler error messages sequentially, type `C-x `'
(`next-error').  The character following the `C-x' is the backquote or
"grave accent," not the single-quote.  This command is available in all
buffers, not just in `*compilation*'; it displays the next error
message at the top of one window and source location of the error in
another window.

   The first time `C-x `' is used after the start of a compilation, it
moves to the first error's location.  Subsequent uses of `C-x `'
advance down to subsequent errors.  If you visit a specific error
message with <RET> or `Mouse-2', subsequent `C-x `' commands advance
from there.  When `C-x `' gets to the end of the buffer and finds no
more error messages to visit, it fails and signals an Emacs error.

   `C-u C-x `' starts scanning from the beginning of the compilation
buffer.  This is one way to process the same set of errors again.

   Compilation mode also redefines the keys <SPC> and <DEL> to scroll
by screenfuls, and `M-n' and `M-p' to move to the next or previous
error message.  You can also use `M-{' and `M-}' to move up or down to
an error message for a different source file.

   The features of Compilation mode are also available in a minor mode
called Compilation Minor mode.  This lets you parse error messages in
any buffer, not just a normal compilation output buffer.  Type `M-x
compilation-minor-mode' to enable the minor mode.  This defines the keys
<RET> and `Mouse-2', as in the Compilation major mode.

   Compilation minor mode works in any buffer, as long as the contents
are in a format that it understands.  In an Rlogin buffer (*note Remote
Host::.), Compilation minor mode automatically accesses remote source
files by FTP (*note File Names::.).


File: emacs,  Node: Compilation Shell,  Next: Debuggers,  Prev: Compilation Mode,  Up: Building

Subshells for Compilation
=========================

   Emacs uses a shell to run the compilation command, but specifies the
option for a noninteractive shell.  This means, in particular, that the
shell should start with no prompt.  If you find your usual shell prompt
making an unsightly appearance in the `*compilation*' buffer, it means
you have made a mistake in your shell's init file by setting the prompt
unconditionally.  (This init file's name may be `.bashrc', `.profile',
`.cshrc', `.shrc', or various other things, depending on the shell you
use.)  The shell init file should set the prompt only if there already
is a prompt.  In csh, here is how to do it:

     if ($?prompt) set prompt = ...

And here's how to do it in bash:

     if [ "${PS1+set}" = set ]
     then PS1=...
     fi

   There may well be other things that your shell's init file ought to
do only for an interactive shell.  You can use the same method to
conditionalize them.

   The MS-DOS "operating system" does not support asynchronous
subprocesses; to work around this lack, `M-x compile' runs the
compilation command synchronously on MS-DOS.  As a consequence, you must
wait until the command finishes before you can do anything else in
Emacs.  *Note MS-DOS::.


File: emacs,  Node: Debuggers,  Next: Executing Lisp,  Prev: Compilation Shell,  Up: Building

Running Debuggers Under Emacs
=============================

   The GUD (Grand Unified Debugger) library provides an interface to
various symbolic debuggers from within Emacs.  We recommend the debugger
GDB, which is free software, but you can also run DBX, SDB or XDB if you
have them.  GUD can also serve as an interface to the Perl's debugging
mode, the Python debugger PDB, and to JDB, the Java Debugger.

* Menu:

* Starting GUD::	How to start a debugger subprocess.
* Debugger Operation::	Connection between the debugger and source buffers.
* Commands of GUD::	Key bindings for common commands.
* GUD Customization::	Defining your own commands for GUD.


File: emacs,  Node: Starting GUD,  Next: Debugger Operation,  Up: Debuggers

Starting GUD
------------

   There are several commands for starting a debugger, each
corresponding to a particular debugger program.

`M-x gdb <RET> FILE <RET>'
     Run GDB as a subprocess of Emacs.  This command creates a buffer
     for input and output to GDB, and switches to it.  If a GDB buffer
     already exists, it just switches to that buffer.

`M-x dbx <RET> FILE <RET>'
     Similar, but run DBX instead of GDB.

`M-x xdb <RET> FILE <RET>'
     Similar, but run XDB instead of GDB.  Use the variable
     `gud-xdb-directories' to specify directories to search for source
     files.

`M-x sdb <RET> FILE <RET>'
     Similar, but run SDB instead of GDB.

     Some versions of SDB do not mention source file names in their
     messages.  When you use them, you need to have a valid tags table
     (*note Tags::.) in order for GUD to find functions in the source
     code.  If you have not visited a tags table or the tags table
     doesn't list one of the functions, you get a message saying `The
     sdb support requires a valid tags table to work'.  If this
     happens, generate a valid tags table in the working directory and
     try again.

`M-x perldb <RET> FILE <RET>'
     Run the Perl interpreter in debug mode to debug FILE, a Perl
     program.

`M-x jdb <RET> FILE <RET>'
     Run the Java debugger to debug FILE.

`M-x pdb <RET> FILE <RET>'
     Run the Python debugger to debug FILE.

   Each of these commands takes one argument: a command line to invoke
the debugger.  In the simplest case, specify just the name of the
executable file you want to debug.  You may also use options that the
debugger supports.  However, shell wildcards and variables are not
allowed.  GUD assumes that the first argument not starting with a `-'
is the executable file name.

   Emacs can only run one debugger process at a time.


File: emacs,  Node: Debugger Operation,  Next: Commands of GUD,  Prev: Starting GUD,  Up: Debuggers

Debugger Operation
------------------

   When you run a debugger with GUD, the debugger uses an Emacs buffer
for its ordinary input and output.  This is called the GUD buffer.  The
debugger displays the source files of the program by visiting them in
Emacs buffers.  An arrow (`=>') in one of these buffers indicates the
current execution line.  Moving point in this buffer does not move the
arrow.

   You can start editing these source files at any time in the buffers
that were made to display them.  The arrow is not part of the file's
text; it appears only on the screen.  If you do modify a source file,
keep in mind that inserting or deleting lines will throw off the arrow's
positioning; GUD has no way of figuring out which line corresponded
before your changes to the line number in a debugger message.  Also,
you'll typically have to recompile and restart the program for your
changes to be reflected in the debugger's tables.

   If you wish, you can control your debugger process entirely through
the debugger buffer, which uses a variant of Shell mode.  All the usual
commands for your debugger are available, and you can use the Shell mode
history commands to repeat them.  *Note Shell Mode::.


File: emacs,  Node: Commands of GUD,  Next: GUD Customization,  Prev: Debugger Operation,  Up: Debuggers

Commands of GUD
---------------

   The GUD interaction buffer uses a variant of Shell mode, so the
commands of Shell mode are available (*note Shell Mode::.).  GUD mode
also provides commands for setting and clearing breakpoints, for
selecting stack frames, and for stepping through the program.  These
commands are available both in the GUD buffer and globally, but with
different key bindings.

   The breakpoint commands are usually used in source file buffers,
because that is the way to specify where to set or clear the breakpoint.
Here's the global command to set a breakpoint:

`C-x <SPC>'
     Set a breakpoint on the source line that point is on.

   Here are the other special commands provided by GUD.  The keys
starting with `C-c' are available only in the GUD interaction buffer.
The key bindings that start with `C-x C-a' are available in the GUD
interaction buffer and also in source files.

`C-c C-l'
`C-x C-a C-l'
     Display in another window the last line referred to in the GUD
     buffer (that is, the line indicated in the last location message).
     This runs the command `gud-refresh'.

`C-c C-s'
`C-x C-a C-s'
     Execute a single line of code (`gud-step').  If the line contains
     a function call, execution stops after entering the called
     function.

`C-c C-n'
`C-x C-a C-n'
     Execute a single line of code, stepping across entire function
     calls at full speed (`gud-next').

`C-c C-i'
`C-x C-a C-i'
     Execute a single machine instruction (`gud-stepi').

`C-c C-r'
`C-x C-a C-r'
     Continue execution without specifying any stopping point.  The
     program will run until it hits a breakpoint, terminates, or gets a
     signal that the debugger is checking for (`gud-cont').

`C-c C-d'
`C-x C-a C-d'
     Delete the breakpoint(s) on the current source line, if any
     (`gud-remove').  If you use this command in the GUD interaction
     buffer, it applies to the line where the program last stopped.

`C-c C-t'
`C-x C-a C-t'
     Set a temporary breakpoint on the current source line, if any.  If
     you use this command in the GUD interaction buffer, it applies to
     the line where the program last stopped.

   The above commands are common to all supported debuggers.  If you are
using GDB or (some versions of) DBX, these additional commands are
available:

`C-c <'
`C-x C-a <'
     Select the next enclosing stack frame (`gud-up').  This is
     equivalent to the `up' command.

`C-c >'
`C-x C-a >'
     Select the next inner stack frame (`gud-down').  This is
     equivalent to the `down' command.

   If you are using GDB, these additional key bindings are available:

`<TAB>'
     With GDB, complete a symbol name (`gud-gdb-complete-command').
     This key is available only in the GUD interaction buffer, and
     requires GDB versions 4.13 and later.

`C-c C-f'
`C-x C-a C-f'
     Run the program until the selected stack frame returns (or until it
     stops for some other reason).

   These commands interpret a numeric argument as a repeat count, when
that makes sense.

   Because <TAB> serves as a completion command, you can't use it to
enter a tab as input to the program you are debugging with GDB.
Instead, type `C-q <TAB>' to enter a tab.


File: emacs,  Node: GUD Customization,  Prev: Commands of GUD,  Up: Debuggers

GUD Customization
-----------------

   On startup, GUD runs one of the following hooks: `gdb-mode-hook', if
you are using GDB; `dbx-mode-hook', if you are using DBX;
`sdb-mode-hook', if you are using SDB; `xdb-mode-hook', if you are
using XDB; `perldb-mode-hook', for Perl debugging mode;
`jdb-mode-hook', for PDB; `jdb-mode-hook', for JDB.  You can use these
hooks to define custom key bindings for the debugger interaction
buffer.  *Note Hooks::.

   Here is a convenient way to define a command that sends a particular
command string to the debugger, and set up a key binding for it in the
debugger interaction buffer:

     (gud-def FUNCTION CMDSTRING BINDING DOCSTRING)

   This defines a command named FUNCTION which sends CMDSTRING to the
debugger process, and gives it the documentation string DOCSTRING.  You
can use the command thus defined in any buffer.  If BINDING is
non-`nil', `gud-def' also binds the command to `C-c BINDING' in the GUD
buffer's mode and to `C-x C-a BINDING' generally.

   The command string CMDSTRING may contain certain `%'-sequences that
stand for data to be filled in at the time FUNCTION is called:

`%f'
     The name of the current source file.  If the current buffer is the
     GUD buffer, then the "current source file" is the file that the
     program stopped in.

`%l'
     The number of the current source line.  If the current buffer is
     the GUD buffer, then the "current source line" is the line that
     the program stopped in.

`%e'
     The text of the C lvalue or function-call expression at or
     adjacent to point.

`%a'
     The text of the hexadecimal address at or adjacent to point.

`%p'
     The numeric argument of the called function, as a decimal number.
     If the command is used without a numeric argument, `%p' stands for
     the empty string.

     If you don't use `%p' in the command string, the command you define
     ignores any numeric argument.


File: emacs,  Node: Executing Lisp,  Next: Lisp Libraries,  Prev: Debuggers,  Up: Building

Executing Lisp Expressions
==========================

   Emacs has several different major modes for Lisp and Scheme.  They
are the same in terms of editing commands, but differ in the commands
for executing Lisp expressions.  Each mode has its own purpose.

Emacs-Lisp mode
     The mode for editing source files of programs to run in Emacs Lisp.
     This mode defines `C-M-x' to evaluate the current defun.  *Note
     Lisp Libraries::.

Lisp Interaction mode
     The mode for an interactive session with Emacs Lisp.  It defines
     `C-j' to evaluate the sexp before point and insert its value in the
     buffer.  *Note Lisp Interaction::.

Lisp mode
     The mode for editing source files of programs that run in Lisps
     other than Emacs Lisp.  This mode defines `C-M-x' to send the
     current defun to an inferior Lisp process.  *Note External Lisp::.

Inferior Lisp mode
     The mode for an interactive session with an inferior Lisp process.
     This mode combines the special features of Lisp mode and Shell mode
     (*note Shell Mode::.).

Scheme mode
     Like Lisp mode but for Scheme programs.

Inferior Scheme mode
     The mode for an interactive session with an inferior Scheme
     process.

   Most editing commands for working with Lisp programs are in fact
available globally.  *Note Programs::.

