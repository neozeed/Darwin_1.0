This is Info file ../info/emacs, produced by Makeinfo version 1.68 from
the input file emacs.texi.

   This is the thirteenth edition of the `GNU Emacs Manual', updated
for Emacs version 20.3

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307 USA

   Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998
Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.


File: emacs,  Node: Scroll Bars,  Next: Menu Bars,  Prev: Frame Parameters,  Up: Frames

Scroll Bars
===========

   When using X, Emacs normally makes a "scroll bar" at the left of
each Emacs window.  The scroll bar runs the height of the window, and
shows a moving rectangular inner box which represents the portion of the
buffer currently displayed.  The entire height of the scroll bar
represents the entire length of the buffer.

   You can use `Mouse-2' (normally, the middle button) in the scroll
bar to move or drag the inner box up and down.  If you move it to the
top of the scroll bar, you see the top of the buffer.  If you move it to
the bottom of the scroll bar, you see the bottom of the buffer.

   The left and right buttons in the scroll bar scroll by controlled
increments.  `Mouse-1' (normally, the left button) moves the line at
the level where you click up to the top of the window.  `Mouse-3'
(normally, the right button) moves the line at the top of the window
down to the level where you click.  By clicking repeatedly in the same
place, you can scroll by the same distance over and over.

   Aside from scrolling, you can also click `C-Mouse-2' in the scroll
bar to split a window vertically.  The split occurs on the line where
you click.

   You can enable or disable Scroll Bar mode with the command `M-x
scroll-bar-mode'.  With no argument, it toggles the use of scroll bars.
With an argument, it turns use of scroll bars on if and only if the
argument is positive.  This command applies to all frames, including
frames yet to be created.  You can use the X resource
`verticalScrollBars' to control the initial setting of Scroll Bar mode.
*Note Resources X::.

   To enable or disable scroll bars for just the selected frame, use the
`M-x toggle-scroll-bar' command.


File: emacs,  Node: Menu Bars,  Next: Faces,  Prev: Scroll Bars,  Up: Frames

Menu Bars
=========

   You can turn display of menu bars on or off with `M-x
menu-bar-mode'.  With no argument, this command toggles Menu Bar mode, a
minor mode.  With an argument, the command turns Menu Bar mode on if the
argument is positive, off if the argument is not positive.  You can use
the X resource `menuBarLines' to control the initial setting of Menu
Bar mode.  *Note Resources X::.  Expert users often turn off the menu
bar, especially on text-only terminals, where this makes one additional
line available for text.

   *Note Menu Bar:: for information on how to invoke commands with the
menu bar.


File: emacs,  Node: Faces,  Next: Font Lock,  Prev: Menu Bars,  Up: Frames

Using Multiple Typefaces
========================

   When using Emacs with X, you can set up multiple styles of displaying
characters.  The aspects of style that you can control are the type
font, the foreground color, the background color, and whether to
underline.  Emacs on MS-DOS supports faces partially by letting you
control the foreground and background colors of each face (*note
MS-DOS::.).

   The way you control display style is by defining named "faces".
Each face can specify a type font, a foreground color, a background
color, and an underline flag; but it does not have to specify all of
them.

   The style of display used for a given character in the text is
determined by combining several faces.  Any aspect of the display style
that isn't specified by overlays or text properties comes from the frame
itself.

   Enriched mode, the mode for editing formatted text, includes several
commands and menus for specifying faces.  *Note Format Faces::, for how
to specify the font for text in the buffer.  *Note Format Colors::, for
how to specify the foreground and background color.

   To alter the appearance of a face, use the customization buffer.
*Note Face Customization::.  You can also use X resources to specify
attributes of particular faces (*note Resources X::.).

   To see what faces are currently defined, and what they look like,
type `M-x list-faces-display'.  It's possible for a given face to look
different in different frames; this command shows the appearance in the
frame in which you type it.  Here's a list of the standardly defined
faces:

`default'
     This face is used for ordinary text that doesn't specify any other
     face.

`modeline'
     This face is used for mode lines.  By default, it's set up as the
     inverse of the default face.  *Note Display Vars::.

`highlight'
     This face is used for highlighting portions of text, in various
     modes.

`region'
     This face is used for displaying a selected region (when Transient
     Mark mode is enabled--see below).

`secondary-selection'
     This face is used for displaying a secondary selection (*note
     Secondary Selection::.).

`bold'
     This face uses a bold variant of the default font, if it has one.

`italic'
     This face uses an italic variant of the default font, if it has
     one.

`bold-italic'
     This face uses a bold italic variant of the default font, if it
     has one.

`underline'
     This face underlines text.

   When Transient Mark mode is enabled, the text of the region is
highlighted when the mark is active.  This uses the face named
`region'; you can control the style of highlighting by changing the
style of this face (*note Face Customization::.).  *Note Transient
Mark::, for more information about Transient Mark mode and activation
and deactivation of the mark.

   One easy way to use faces is to turn on Font Lock mode.  This minor
mode, which is always local to a particular buffer, arranges to choose
faces according to the syntax of the text you are editing.  It can
recognize comments and strings in most languages; in several languages,
it can also recognize and properly highlight various other important
constructs.  *Note Font Lock::, for more information about Font Lock
mode and syntactic highlighting.

   You can print out the buffer with the highlighting that appears on
your screen using the command `ps-print-buffer-with-faces'.  *Note
Postscript::.


File: emacs,  Node: Font Lock,  Next: Support Modes,  Prev: Faces,  Up: Frames

Font Lock mode
==============

   Font Lock mode is a minor mode, always local to a particular buffer,
which highlights (or "fontifies") using various faces according to the
syntax of the text you are editing.  It can recognize comments and
strings in most languages; in several languages, it can also recognize
and properly highlight various other important constructs--for example,
names of functions being defined or reserved keywords.

   The command `M-x font-lock-mode' turns Font Lock mode on or off
according to the argument, and toggles the mode when it has no argument.
The function `turn-on-font-lock' unconditionally enables Font Lock
mode.  This is useful in mode-hook functions.  For example, to enable
Font Lock mode whenever you edit a C file, you can do this:

     (add-hook 'c-mode-hook 'turn-on-font-lock)

   To turn on Font Lock mode automatically in all modes which support
it, use the function `global-font-lock-mode', like this:

     (global-font-lock-mode t)

   In Font Lock mode, when you edit the text, the highlighting updates
automatically in the line that you changed.  Most changes don't affect
the highlighting of subsequent lines, but occasionally they do.  To
rehighlight a range of lines, use the command `M-g M-g'
(`font-lock-fontify-block').

   In certain major modes, `M-g M-g' refontifies the entire current
function.  (The variable `font-lock-mark-block-function' controls how
to find the current function.)  In other major modes, `M-g M-g'
refontifies 16 lines above and below point.

   With a prefix argument N, `M-g M-g' refontifies N lines above and
below point, regardless of the mode.

   To get the full benefit of Font Lock mode, you need to choose a
default font which has bold, italic, and bold-italic variants; or else
you need to have a color or gray-scale screen.

   The variable `font-lock-maximum-decoration' specifies the preferred
level of fontification, for modes that provide multiple levels.  Level
1 is the least amount of fontification; some modes support levels as
high as 3.  The normal default is "as high as possible."  You can
specify an integer, which applies to all modes, or you can specify
different numbers for particular major modes; for example, to use level
1 for C/C++ modes, and the default level otherwise, use this:

     (setq font-lock-maximum-decoration
           '((c-mode . 1) (c++-mode . 1)))

   Fontification can be too slow for large buffers, so you can suppress
it.  The variable `font-lock-maximum-size' specifies a buffer size,
beyond which buffer fontification is suppressed.

   Comment and string fontification (or "syntactic" fontification)
relies on analysis of the syntactic structure of the buffer text.  For
the purposes of speed, some modes including C mode and Lisp mode rely on
a special convention: an open-parenthesis in the leftmost column always
defines the beginning of a defun, and is thus always outside any string
or comment.  (*Note Defuns::.)  If you don't follow this convention,
then Font Lock mode can misfontify the text after an open-parenthesis in
the leftmost column that is inside a string or comment.

   The variable `font-lock-beginning-of-syntax-function' (always
buffer-local) specifies how Font Lock mode can find a position
guaranteed to be outside any comment or string.  In modes which use the
leftmost column parenthesis convention, the default value of the
variable is `beginning-of-defun'--that tells Font Lock mode to use the
convention.  If you set this variable to `nil', Font Lock no longer
relies on the convention.  This avoids incorrect results, but the price
is that, in some cases, fontification for a changed text must rescan
buffer text from the beginning of the buffer.

   Font Lock highlighting patterns already exist for many modes, but you
may want to fontify additional patterns.  You can use the function
`font-lock-add-keywords', to add your own highlighting patterns for a
particular mode.  For example, to highlight `FIXME:' words in C
comments, use this:

     (font-lock-add-keywords
      'c-mode
      '(("\\<\\(FIXME\\):" 1 font-lock-warning-face t)))


File: emacs,  Node: Support Modes,  Next: Highlight Changes,  Prev: Font Lock,  Up: Frames

Font Lock Support Modes
=======================

   Font Lock support modes make Font Lock mode faster for large buffers.
There are two support modes: Fast Lock mode and Lazy Lock mode.  They
use two different methods of speeding up Font Lock mode.

* Menu:

* Fast Lock Mode::      Saving font information in files.
* Lazy Lock Mode::      Fontifying only text that is actually displayed.
* Fast or Lazy::        Which support mode is best for you?


File: emacs,  Node: Fast Lock Mode,  Next: Lazy Lock Mode,  Up: Support Modes

Fast Lock Mode
--------------

   To make Font Lock mode faster for buffers visiting large files, you
can use Fast Lock mode.  Fast Lock mode saves the font information for
each file in a separate cache file; each time you visit the file, it
rereads the font information from the cache file instead of refontifying
the text from scratch.

   The command `M-x fast-lock-mode' turns Fast Lock mode on or off,
according to the argument (with no argument, it toggles).  You can also
arrange to enable Fast Lock mode whenever you use Font Lock mode, like
this:

     (setq font-lock-support-mode 'fast-lock-mode)

   It is not worth writing a cache file for small buffers.  Therefore,
the variable `fast-lock-minimum-size' specifies a minimum file size for
caching font information.

   The variable `fast-lock-cache-directories' specifies where to put
the cache files.  Its value is a list of directories to try; `"."'
means the same directory as the file being edited.  The default value is
`("." "~/.emacs-flc")', which means to use the same directory if
possible, and otherwise the directory `~/.emacs-flc'.

   The variable `fast-lock-save-others' specifies whether Fast Lock
mode should save cache files for files that you do not own.  A
non-`nil' value means yes (and that is the default).


File: emacs,  Node: Lazy Lock Mode,  Next: Fast or Lazy,  Prev: Fast Lock Mode,  Up: Support Modes

Lazy Lock Mode
--------------

   To make Font Lock mode faster for large buffers, you can use Lazy
Lock mode to reduce the amount of text that is fontified.  In Lazy Lock
mode, buffer fontification is demand-driven; it happens to portions of
the buffer that are about to be displayed.  And fontification of your
changes is deferred; it happens only when Emacs has been idle for a
certain short period of time.

   The command `M-x lazy-lock-mode' turns Lazy Lock mode on or off,
according to the argument (with no argument, it toggles).  You can also
arrange to enable Lazy Lock mode whenever you use Font Lock mode, like
this:

     (setq font-lock-support-mode 'lazy-lock-mode)

   It is not worth avoiding buffer fontification for small buffers.
Therefore, the variable `lazy-lock-minimum-size' specifies a minimum
buffer size for demand-driven buffer fontification.  Buffers smaller
than that are fontified all at once, as in plain Font Lock mode.

   When you alter the buffer, Lazy Lock mode defers fontification of the
text you changed.  The variable `lazy-lock-defer-time' specifies how
many seconds Emacs must be idle before it starts fontifying your
changes.  If the value is 0, then changes are fontified immediately, as
in plain Font Lock mode.

   Lazy Lock mode normally fontifies newly visible portions of the
buffer before they are first displayed.  However, if the value of
`lazy-lock-defer-on-scrolling' is non-`nil', newly visible text is
fontified only when Emacs is idle for `lazy-lock-defer-time' seconds.

   In some modes, including C mode and Emacs Lisp mode, changes in one
line's contents can alter the context for subsequent lines, and thus
change how they ought to be fontified.  Ordinarily, you must type `M-g
M-g' to refontify the subsequent lines.  However, if you set the
variable `lazy-lock-defer-contextually' to non-`nil', Lazy Lock mode
does this automatically, after `lazy-lock-defer-time' seconds.

   When Emacs is idle for a long time, Lazy Lock fontifies additional
portions of the buffer, not yet displayed, in case you will display them
later.  This is called "stealth fontification".

   The variable `lazy-lock-stealth-time' specifies how many seconds
Emacs has to be idle before stealth fontification starts.  A value of
`nil' means no stealth fontification.  The variables
`lazy-lock-stealth-lines' and `lazy-lock-stealth-verbose' specify the
granularity and verbosity of stealth fontification.


File: emacs,  Node: Fast or Lazy,  Prev: Lazy Lock Mode,  Up: Support Modes

Fast Lock or Lazy Lock?
-----------------------

   Here is a simple guide to help you choose one of the Font Lock
support modes.

   * Fast Lock mode intervenes only during file visiting and buffer
     killing (and related events); therefore buffer editing and window
     scrolling are no faster or slower than in plain Font Lock mode.

   * Fast Lock mode is slower at reading a cache file than Lazy Lock
     mode is at fontifying a window; therefore Fast Lock mode is slower
     at visiting a file than Lazy Lock mode.

   * Lazy Lock mode intervenes during window scrolling to fontify text
     that scrolls onto the screen; therefore, scrolling is slower than
     in plain Font Lock mode.

   * Lazy Lock mode doesn't fontify during buffer editing (it defers
     fontification of changes); therefore, editing is faster than in
     plain Font Lock mode.

   * Fast Lock mode can be fooled by a file that is kept under version
     control software; therefore buffer fontification may occur even
     when a cache file exists for the file.

   * Fast Lock mode only works with a buffer visiting a file; Lazy Lock
     mode works with any buffer.

   * Fast Lock mode generates cache files; Lazy Lock mode does not.

   The variable `font-lock-support-mode' specifies which of these
support modes to use; for example, to specify that Fast Lock mode is
used for C/C++ modes, and Lazy Lock mode otherwise, set the variable
like this:

     (setq font-lock-support-mode
           '((c-mode . fast-lock-mode) (c++-mode . fast-lock-mode)
             (t . lazy-lock-mode)))


File: emacs,  Node: Highlight Changes,  Next: Misc X,  Prev: Support Modes,  Up: Frames

Highlight Changes Mode
======================

   Use `M-x highlight-changes-mode' to enable a minor mode that uses
faces (colors, typically) to indicate which parts of the buffer were
changed most recently.


File: emacs,  Node: Misc X,  Next: Non-Window Terminals,  Prev: Highlight Changes,  Up: Frames

Miscellaneous X Window Features
===============================

   The following commands let you create, delete and operate on frames:

`C-z'
     Iconify the selected Emacs frame (`iconify-or-deiconify-frame').
     The normal meaning of `C-z', to suspend Emacs, is not useful under
     a window system, so it has a different binding in that case.

     If you type this command on an Emacs frame's icon, it deiconifies
     the frame.

`C-x 5 0'
     Delete the selected frame (`delete-frame').  This is not allowed if
     there is only one frame.

`C-x 5 o'
     Select another frame, raise it, and warp the mouse to it so that it
     stays selected.  If you repeat this command, it cycles through all
     the frames on your terminal.


File: emacs,  Node: Non-Window Terminals,  Prev: Misc X,  Up: Frames

Non-Window Terminals
====================

   If your terminal does not have a window system that Emacs supports,
then it can display only one Emacs frame at a time.  However, you can
still create multiple Emacs frames, and switch between them.  Switching
frames on these terminals is much like switching between different
window configurations.

   Use `C-x 5 2' to create a new frame and switch to it; use `C-x 5 o'
to cycle through the existing frames; use `C-x 5 0' to delete the
current frame.

   Each frame has a number to distinguish it.  If your terminal can
display only one frame at a time, the selected frame's number N appears
near the beginning of the mode line, in the form `FN'.

   `FN' is actually the frame's name.  You can also specify a different
name if you wish, and you can select a frame by its name.  Use the
command `M-x set-frame-name <RET> NAME <RET>' to specify a new name for
the selected frame, and use `M-x select-frame-by-name <RET> NAME <RET>'
to select a frame according to its name.  The name you specify appears
in the mode line when the frame is selected.


File: emacs,  Node: International,  Next: Major Modes,  Prev: Frames,  Up: Top

International Character Set Support
***********************************

   Emacs supports a wide variety of international character sets,
including European variants of the Latin alphabet, as well as Chinese,
Devanagari (Hindi and Marathi), Ethiopian, Greek, IPA, Japanese, Korean,
Lao, Russian, Thai, Tibetan, and Vietnamese scripts.  These features
have been merged from the modified version of Emacs known as MULE (for
"MULti-lingual Enhancement to GNU Emacs")

* Menu:

* International Intro::     Basic concepts of multibyte characters.
* Enabling Multibyte::      Controlling whether to use multibyte characters.
* Language Environments::   Setting things up for the language you use.
* Input Methods::           Entering text characters not on your keyboard.
* Select Input Method::     Specifying your choice of input methods.
* Coding Systems::          Character set conversion when you read and
                              write files, and so on.
* Recognize Coding::        How Emacs figures out which conversion to use.
* Specify Coding::          Various ways to choose which conversion to use.
* Fontsets::                Fontsets are collections of fonts
                              that cover the whole spectrum of characters.
* Defining Fontsets::       Defining a new fontset.
* Single-Byte European Support::
                            You can pick one European character set
                            to use without multibyte characters.


File: emacs,  Node: International Intro,  Next: Enabling Multibyte,  Up: International

Introduction to International Character Sets
============================================

   The users of these scripts have established many more-or-less
standard coding systems for storing files.  Emacs internally uses a
single multibyte character encoding, so that it can intermix characters
from all these scripts in a single buffer or string.  This encoding
represents each non-ASCII character as a sequence of bytes in the range
0200 through 0377.  Emacs translates between the multibyte character
encoding and various other coding systems when reading and writing
files, when exchanging data with subprocesses, and (in some cases) in
the `C-q' command (see below).

   The command `C-h h' (`view-hello-file') displays the file
`etc/HELLO', which shows how to say "hello" in many languages.  This
illustrates various scripts.

   Keyboards, even in the countries where these character sets are used,
generally don't have keys for all the characters in them.  So Emacs
supports various "input methods", typically one for each script or
language, to make it convenient to type them.

   The prefix key `C-x <RET>' is used for commands that pertain to
multibyte characters, coding systems, and input methods.


File: emacs,  Node: Enabling Multibyte,  Next: Language Environments,  Prev: International Intro,  Up: International

Enabling Multibyte Characters
=============================

   You can enable or disable multibyte character support, either for
Emacs as a whole, or for a single buffer.  When multibyte characters are
disabled in a buffer, then each byte in that buffer represents a
character, even codes 0200 through 0377.  The old features for
supporting the European character sets, ISO Latin-1 and ISO Latin-2,
work as they did in Emacs 19.

   However, there is no need to turn off multibyte character support to
use ISO Latin-1 or ISO Latin-2; the Emacs multibyte character set
includes all the characters in these character sets, and Emacs can
translate automatically to and from either of these ISO codes.

   To edit a particular file in unibyte representation, visit it using
`find-file-literally'.  *Note Visiting::.  To convert a buffer in
multibyte representation into a single-byte representation of the same
characters, the easiest way is to save the contents in a file, kill the
buffer, and find the file again with `find-file-literally'.

   To turn off multibyte character support by default, start Emacs with
the `--unibyte' option (*note Initial Options::.), or set the
environment variable `EMACS_UNIBYTE'.

   The mode line indicates whether multibyte character support is
enabled in the current buffer.  If it is, there are two or more
characters (most often two dashes) before the colon near the beginning
of the mode line.  When multibyte characters are not enabled, just one
dash precedes the colon.

   When multibyte characters are enabled, character codes 0240 (octal)
through 0377 (octal) are not really legitimate in the buffer.  The valid
non-ASCII printing characters have codes that start from 0400.

   If you type a self-inserting character in the invalid range 0240
through 0377, Emacs assumes you intended to use one of the ISO Latin-N
character sets, and converts it to the Emacs code representing that
Latin-N character.  You select *which* ISO Latin character set to use
though your choice of language environment (*note Language
Environments::.).  If you do not specify a choice, the default is
Latin-1.

   The same thing happens when you use `C-q' to enter an octal code in
this range.


File: emacs,  Node: Language Environments,  Next: Input Methods,  Prev: Enabling Multibyte,  Up: International

Language Environments
=====================

   All supported character sets are supported in Emacs buffers whenever
multibyte characters are enabled; there is no need to select a
particular language in order to display its characters in an Emacs
buffer.  However, it is important to select a "language environment" in
order to set various defaults.  The language environment really
represents a choice of preferred script (more or less) rather that a
choice of language.

   The language environment controls which coding systems to recognize
when reading text (*note Recognize Coding::.).  This applies to files,
incoming mail, netnews, and any other text you read into Emacs.  It may
also specify the default coding system to use when you create a file.
Each language environment also specifies a default input method.

   The way to select a language environment is with the command `M-x
set-language-environment'.  It makes no difference which buffer is
current when you use this command, because the effects apply globally to
the Emacs session.  The supported language environments include:

     Chinese-BIG5, Chinese-CNS, Chinese-GB, Cyrillic-Alternativnyj,
     Cyrillic-ISO, Cyrillic-KOI8, Devanagari, English, Ethiopic, Greek,
     Hebrew, Japanese, Korean, Lao, Latin-1, Latin-2, Latin-3, Latin-4,
     Latin-5, Thai, Tibetan, and Vietnamese.

   Some operating systems let you specify the language you are using by
setting locale environment variables.  Emacs handles one common special
case of this: if your locale name for character types contains the
string `8859-N', Emacs automatically selects the corresponding language
environment.

   To display information about the effects of a certain language
environment LANG-ENV, use the command `C-h L LANG-ENV <RET>'
(`describe-language-environment').  This tells you which languages this
language environment is useful for, and lists the character sets,
coding systems, and input methods that go with it.  It also shows some
sample text to illustrate scripts used in this language environment.
By default, this command describes the chosen language environment.

   You can customize any language environment with the normal hook
`set-language-environment-hook'.  The command
`set-language-environment' runs that hook after setting up the new
language environment.  The hook functions can test for a specific
language environment by checking the variable
`current-language-environment'.

   Before it starts to set up the new language environment,
`set-language-environment' first runs the hook
`exit-language-environment-hook'.  This hook is useful for undoing
customizations that were made with `set-language-environment-hook'.
For instance, if you set up a special key binding in a specific language
environment using `set-language-environment-hook', you should set up
`exit-language-environment-hook' to restore the normal binding for that
key.


File: emacs,  Node: Input Methods,  Next: Select Input Method,  Prev: Language Environments,  Up: International

Input Methods
=============

   An "input method" is a kind of character conversion designed
specifically for interactive input.  In Emacs, typically each language
has its own input method; sometimes several languages which use the same
characters can share one input method.  A few languages support several
input methods.

   The simplest kind of input method works by mapping ASCII letters into
another alphabet.  This is how the Greek and Russian input methods work.

   A more powerful technique is composition: converting sequences of
characters into one letter.  Many European input methods use composition
to produce a single non-ASCII letter from a sequence that consists of a
letter followed by accent characters.  For example, some methods convert
the sequence `'a' into a single accented letter.  These input methods
have no special commands of their own; all they do is compose sequences
of printing characters.

   The input methods for syllabic scripts typically use mapping followed
by composition.  The input methods for Thai and Korean work this way.
First, letters are mapped into symbols for particular sounds or tone
marks; then, sequences of these which make up a whole syllable are
mapped into one syllable sign.

   Chinese and Japanese require more complex methods.  In Chinese input
methods, first you enter the phonetic spelling of a Chinese word (in
input method `chinese-py', among others), or a sequence of portions of
the character (input methods `chinese-4corner' and `chinese-sw', and
others).  Since one phonetic spelling typically corresponds to many
different Chinese characters, you must select one of the alternatives
using special Emacs commands.  Keys such as `C-f', `C-b', `C-n', `C-p',
and digits have special definitions in this situation, used for
selecting among the alternatives.  <TAB> displays a buffer showing all
the possibilities.

   In Japanese input methods, first you input a whole word using
phonetic spelling; then, after the word is in the buffer, Emacs converts
it into one or more characters using a large dictionary.  One phonetic
spelling corresponds to many differently written Japanese words, so you
must select one of them; use `C-n' and `C-p' to cycle through the
alternatives.

   Sometimes it is useful to cut off input method processing so that the
characters you have just entered will not combine with subsequent
characters.  For example, in input method `latin-1-postfix', the
sequence `e '' combines to form an `e' with an accent.  What if you
want to enter them as separate characters?

   One way is to type the accent twice; that is a special feature for
entering the separate letter and accent.  For example, `e ' '' gives
you the two characters `e''.  Another way is to type another letter
after the `e'--something that won't combine with that--and immediately
delete it.  For example, you could type `e e <DEL> '' to get separate
`e' and `''.

   Another method, more general but not quite as easy to type, is to use
`C-\ C-\' between two characters to stop them from combining.  This is
the command `C-\' (`toggle-input-method') used twice.  *Note Select
Input Method::.

   `C-\ C-\' is especially useful inside an incremental search, because
it stops waiting for more characters to combine, and starts searching
for what you have already entered.

   The variables `input-method-highlight-flag' and
`input-method-verbose-flag' control how input methods explain what is
happening.  If `input-method-highlight-flag' is non-`nil', the partial
sequence is highlighted in the buffer.  If `input-method-verbose-flag'
is non-`nil', the list of possible characters to type next is displayed
in the echo area (but not when you are in the minibuffer).


File: emacs,  Node: Select Input Method,  Next: Coding Systems,  Prev: Input Methods,  Up: International

Selecting an Input Method
=========================

`C-\'
     Enable or disable use of the selected input method.

`C-x <RET> C-\ METHOD <RET>'
     Select a new input method for the current buffer.

`C-h I METHOD <RET>'
`C-h C-\ METHOD <RET>'
     Describe the input method METHOD (`describe-input-method').  By
     default, it describes the current input method (if any).  This
     description should give you the full details of how to use any
     particular input method.

`M-x list-input-methods'
     Display a list of all the supported input methods.

   To choose an input method for the current buffer, use `C-x <RET>
C-\' (`set-input-method').  This command reads the input method name
with the minibuffer; the name normally starts with the language
environment that it is meant to be used with.  The variable
`current-input-method' records which input method is selected.

   Input methods use various sequences of ASCII characters to stand for
non-ASCII characters.  Sometimes it is useful to turn off the input
method temporarily.  To do this, type `C-\' (`toggle-input-method').
To reenable the input method, type `C-\' again.

   If you type `C-\' and you have not yet selected an input method, it
prompts for you to specify one.  This has the same effect as using `C-x
<RET> C-\' to specify an input method.

   Selecting a language environment specifies a default input method for
use in various buffers.  When you have a default input method, you can
select it in the current buffer by typing `C-\'.  The variable
`default-input-method' specifies the default input method (`nil' means
there is none).

   Some input methods for alphabetic scripts work by (in effect)
remapping the keyboard to emulate various keyboard layouts commonly used
for those scripts.  How to do this remapping properly depends on your
actual keyboard layout.  To specify which layout your keyboard has, use
the command `M-x quail-set-keyboard-layout'.

   To display a list of all the supported input methods, type `M-x
list-input-methods'.  The list gives information about each input
method, including the string that stands for it in the mode line.


File: emacs,  Node: Coding Systems,  Next: Recognize Coding,  Prev: Select Input Method,  Up: International

Coding Systems
==============

   Users of various languages have established many more-or-less
standard coding systems for representing them.  Emacs does not use
these coding systems internally; instead, it converts from various
coding systems to its own system when reading data, and converts the
internal coding system to other coding systems when writing data.
Conversion is possible in reading or writing files, in sending or
receiving from the terminal, and in exchanging data with subprocesses.

   Emacs assigns a name to each coding system.  Most coding systems are
used for one language, and the name of the coding system starts with the
language name.  Some coding systems are used for several languages;
their names usually start with `iso'.  There are also special coding
systems `no-conversion', `raw-text' and `emacs-mule' which do not
convert printing characters at all.

   In addition to converting various representations of non-ASCII
characters, a coding system can perform end-of-line conversion.  Emacs
handles three different conventions for how to separate lines in a file:
newline, carriage-return linefeed, and just carriage-return.

`C-h C CODING <RET>'
     Describe coding system CODING.

`C-h C <RET>'
     Describe the coding systems currently in use.

`M-x list-coding-systems'
     Display a list of all the supported coding systems.

   The command `C-h C' (`describe-coding-system') displays information
about particular coding systems.  You can specify a coding system name
as argument; alternatively, with an empty argument, it describes the
coding systems currently selected for various purposes, both in the
current buffer and as the defaults, and the priority list for
recognizing coding systems (*note Recognize Coding::.).

   To display a list of all the supported coding systems, type `M-x
list-coding-systems'.  The list gives information about each coding
system, including the letter that stands for it in the mode line (*note
Mode Line::.).

   Each of the coding systems that appear in this list--except for
`no-conversion', which means no conversion of any kind--specifies how
and whether to convert printing characters, but leaves the choice of
end-of-line conversion to be decided based on the contents of each file.
For example, if the file appears to use carriage-return linefeed between
lines, that end-of-line conversion will be used.

   Each of the listed coding systems has three variants which specify
exactly what to do for end-of-line conversion:

`...-unix'
     Don't do any end-of-line conversion; assume the file uses newline
     to separate lines.  (This is the convention normally used on Unix
     and GNU systems.)

`...-dos'
     Assume the file uses carriage-return linefeed to separate lines,
     and do the appropriate conversion.  (This is the convention
     normally used on Microsoft systems.)

`...-mac'
     Assume the file uses carriage-return to separate lines, and do the
     appropriate conversion.  (This is the convention normally used on
     the Macintosh system.)

   These variant coding systems are omitted from the
`list-coding-systems' display for brevity, since they are entirely
predictable.  For example, the coding system `iso-latin-1' has variants
`iso-latin-1-unix', `iso-latin-1-dos' and `iso-latin-1-mac'.

   The coding system `raw-text' is good for a file which is mainly
ASCII text, but may contain byte values above 127 which are not meant to
encode non-ASCII characters.  With `raw-text', Emacs copies those byte
values unchanged, and sets `enable-multibyte-characters' to `nil' in
the current buffer so that they will be interpreted properly.
`raw-text' handles end-of-line conversion in the usual way, based on
the data encountered, and has the usual three variants to specify the
kind of end-of-line conversion to use.

   In contrast, the coding system `no-conversion' specifies no
character code conversion at all--none for non-ASCII byte values and
none for end of line.  This is useful for reading or writing binary
files, tar files, and other files that must be examined verbatim.  It,
too, sets `enable-multibyte-characters' to `nil'.

   The easiest way to edit a file with no conversion of any kind is with
the `M-x find-file-literally' command.  This uses `no-conversion', and
also suppresses other Emacs features that might convert the file
contents before you see them.  *Note Visiting::.

   The coding system `emacs-mule' means that the file contains
non-ASCII characters stored with the internal Emacs encoding.  It
handles end-of-line conversion based on the data encountered, and has
the usual three variants to specify the kind of end-of-line conversion.


File: emacs,  Node: Recognize Coding,  Next: Specify Coding,  Prev: Coding Systems,  Up: International

Recognizing Coding Systems
==========================

   Most of the time, Emacs can recognize which coding system to use for
any given file-once you have specified your preferences.

   Some coding systems can be recognized or distinguished by which byte
sequences appear in the data.  However, there are coding systems that
cannot be distinguished, not even potentially.  For example, there is no
way to distinguish between Latin-1 and Latin-2; they use the same byte
values with different meanings.

   Emacs handles this situation by means of a priority list of coding
systems.  Whenever Emacs reads a file, if you do not specify the coding
system to use, Emacs checks the data against each coding system,
starting with the first in priority and working down the list, until it
finds a coding system that fits the data.  Then it converts the file
contents assuming that they are represented in this coding system.

   The priority list of coding systems depends on the selected language
environment (*note Language Environments::.).  For example, if you use
French, you probably want Emacs to prefer Latin-1 to Latin-2; if you use
Czech, you probably want Latin-2 to be preferred.  This is one of the
reasons to specify a language environment.

   However, you can alter the priority list in detail with the command
`M-x prefer-coding-system'.  This command reads the name of a coding
system from the minibuffer, and adds it to the front of the priority
list, so that it is preferred to all others.  If you use this command
several times, each use adds one element to the front of the priority
list.

   Sometimes a file name indicates which coding system to use for the
file.  The variable `file-coding-system-alist' specifies this
correspondence.  There is a special function
`modify-coding-system-alist' for adding elements to this list.  For
example, to read and write all `.txt' files using the coding system
`china-iso-8bit', you can execute this Lisp expression:

     (modify-coding-system-alist 'file "\\.txt\\'" 'china-iso-8bit)

The first argument should be `file', the second argument should be a
regular expression that determines which files this applies to, and the
third argument says which coding system to use for these files.

   You can specify the coding system for a particular file using the
`-*-...-*-' construct at the beginning of a file, or a local variables
list at the end (*note File Variables::.).  You do this by defining a
value for the "variable" named `coding'.  Emacs does not really have a
variable `coding'; instead of setting a variable, it uses the specified
coding system for the file.  For example, `-*-mode: C; coding:
latin-1;-*-' specifies use of the Latin-1 coding system, as well as C
mode.  If you specify the coding explicitly in the file, that overrides
`file-coding-system-alist'.

   The variable `auto-coding-alist' is the strongest way to specify the
coding system for certain patterns of file names; this variable even
overrides `-*-coding:-*-' tags in the file itself.  Emacs uses this
feature for tar and archive files, to prevent Emacs from being confused
by a `-*-coding:-*-' tag in a member of the archive and thinking it
applies to the archive file as a whole.

   Once Emacs has chosen a coding system for a buffer, it stores that
coding system in `buffer-file-coding-system' and uses that coding
system, by default, for operations that write from this buffer into a
file.  This includes the commands `save-buffer' and `write-region'.  If
you want to write files from this buffer using a different coding
system, you can specify a different coding system for the buffer using
`set-buffer-file-coding-system' (*note Specify Coding::.).

   When you send a message with Mail mode (*note Sending Mail::.),
Emacs has four different ways to determine the coding system to use for
encoding the message text.  It tries the buffer's own value of
`buffer-file-coding-system', if that is non-`nil'.  Otherwise, it uses
the value of `sendmail-coding-system', if that is non-`nil'.  The third
way is to use the default coding system for new files, which is
controlled by your choice of language environment, if that is
non-`nil'.  If all of these three values are `nil', Emacs encodes
outgoing mail using the Latin-1 coding system.

   When you get new mail in Rmail, each message is translated
automatically from the coding system it is written in--as if it were a
separate file.  This uses the priority list of coding systems that you
have specified.

   For reading and saving Rmail files themselves, Emacs uses the coding
system specified by the variable `rmail-file-coding-system'.  The
default value is `nil', which means that Rmail files are not translated
(they are read and written in the Emacs internal character code).


File: emacs,  Node: Specify Coding,  Next: Fontsets,  Prev: Recognize Coding,  Up: International

Specifying a Coding System
==========================

   In cases where Emacs does not automatically choose the right coding
system, you can use these commands to specify one:

`C-x <RET> f CODING <RET>'
     Use coding system CODING for the visited file in the current
     buffer.

`C-x <RET> c CODING <RET>'
     Specify coding system CODING for the immediately following command.

`C-x <RET> k CODING <RET>'
     Use coding system CODING for keyboard input.

`C-x <RET> t CODING <RET>'
     Use coding system CODING for terminal output.

`C-x <RET> p CODING <RET>'
     Use coding system CODING for subprocess input and output in the
     current buffer.

`C-x <RET> x CODING <RET>'
     Use coding system CODING for transferring selections to and from
     other programs through the window system.

`C-x <RET> X CODING <RET>'
     Use coding system CODING for transferring *one* selection--the
     next one--to or from the window system.

   The command `C-x <RET> f' (`set-buffer-file-coding-system')
specifies the file coding system for the current buffer--in other
words, which coding system to use when saving or rereading the visited
file.  You specify which coding system using the minibuffer.  Since this
command applies to a file you have already visited, it affects only the
way the file is saved.

   Another way to specify the coding system for a file is when you visit
the file.  First use the command `C-x <RET> c'
(`universal-coding-system-argument'); this command uses the minibuffer
to read a coding system name.  After you exit the minibuffer, the
specified coding system is used for *the immediately following command*.

   So if the immediately following command is `C-x C-f', for example,
it reads the file using that coding system (and records the coding
system for when the file is saved).  Or if the immediately following
command is `C-x C-w', it writes the file using that coding system.
Other file commands affected by a specified coding system include `C-x
C-i' and `C-x C-v', as well as the other-window variants of `C-x C-f'.

   `C-x <RET> c' also affects commands that start subprocesses,
including `M-x shell' (*note Shell::.).

   However, if the immediately following command does not use the coding
system, then `C-x <RET> c' ultimately has no effect.

   An easy way to visit a file with no conversion is with the `M-x
find-file-literally' command.  *Note Visiting::.

   The variable `default-buffer-file-coding-system' specifies the
choice of coding system to use when you create a new file.  It applies
when you find a new file, and when you create a buffer and then save it
in a file.  Selecting a language environment typically sets this
variable to a good choice of default coding system for that language
environment.

   The command `C-x <RET> t' (`set-terminal-coding-system') specifies
the coding system for terminal output.  If you specify a character code
for terminal output, all characters output to the terminal are
translated into that coding system.

   This feature is useful for certain character-only terminals built to
support specific languages or character sets--for example, European
terminals that support one of the ISO Latin character sets.  You need to
specify the terminal coding system when using multibyte text, so that
Emacs knows which characters the terminal can actually handle.

   By default, output to the terminal is not translated at all, unless
Emacs can deduce the proper coding system from your terminal type.

   The command `C-x <RET> k' (`set-keyboard-coding-system') specifies
the coding system for keyboard input.  Character-code translation of
keyboard input is useful for terminals with keys that send non-ASCII
graphic characters--for example, some terminals designed for ISO
Latin-1 or subsets of it.

   By default, keyboard input is not translated at all.

   There is a similarity between using a coding system translation for
keyboard input, and using an input method: both define sequences of
keyboard input that translate into single characters.  However, input
methods are designed to be convenient for interactive use by humans, and
the sequences that are translated are typically sequences of ASCII
printing characters.  Coding systems typically translate sequences of
non-graphic characters.

   The command `C-x <RET> x' (`set-selection-coding-system') specifies
the coding system for sending selected text to the window system, and
for receiving the text of selections made in other applications.  This
command applies to all subsequent selections, until you override it by
using the command again.  The command `C-x <RET> X'
(`set-next-selection-coding-system') specifies the coding system for
the next selection made in Emacs or read by Emacs.

   The command `C-x <RET> p' (`set-buffer-process-coding-system')
specifies the coding system for input and output to a subprocess.  This
command applies to the current buffer; normally, each subprocess has its
own buffer, and thus you can use this command to specify translation to
and from a particular subprocess by giving the command in the
corresponding buffer.

   By default, process input and output are not translated at all.

   The variable `file-name-coding-system' specifies a coding system to
use for encoding file names.  If you set the variable to a coding
system name (as a Lisp symbol or a string), Emacs encodes file names
using that coding system for all file operations.  This makes it
possible to use non-ASCII characters in file names--or, at least, those
non-ASCII characters which the specified coding system can encode.

   If `file-name-coding-system' is `nil', Emacs uses a default coding
system determined by the selected language environment.  In the default
language environment, any non-ASCII characters in file names are not
encoded specially; they appear in the file system using the internal
Emacs representation.

   *Warning:* if you change `file-name-coding-system' (or the language
environment) in the middle of an Emacs session, problems can result if
you have already visited files whose names were encoding using the
earlier coding system and cannot be encoded (or are encoded
differently) under the new coding system.  If you try to save one of
these buffers under the visited file name, saving may use the wrong file
name, or it may get an error.  If such a problem happens, use `C-x C-w'
to specify a new file name for that buffer.

