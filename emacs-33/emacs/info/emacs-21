This is Info file ../info/emacs, produced by Makeinfo version 1.68 from
the input file emacs.texi.

   This is the thirteenth edition of the `GNU Emacs Manual', updated
for Emacs version 20.3

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307 USA

   Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998
Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.


File: emacs,  Node: Editing Binary Files,  Next: Saving Emacs Sessions,  Prev: Two-Column,  Up: Top

Editing Binary Files
====================

   There is a special major mode for editing binary files: Hexl mode.
To use it, use `M-x hexl-find-file' instead of `C-x C-f' to visit the
file.  This command converts the file's contents to hexadecimal and
lets you edit the translation.  When you save the file, it is converted
automatically back to binary.

   You can also use `M-x hexl-mode' to translate an existing buffer
into hex.  This is useful if you visit a file normally and then discover
it is a binary file.

   Ordinary text characters overwrite in Hexl mode.  This is to reduce
the risk of accidentally spoiling the alignment of data in the file.
There are special commands for insertion.  Here is a list of the
commands of Hexl mode:

`C-M-d'
     Insert a byte with a code typed in decimal.

`C-M-o'
     Insert a byte with a code typed in octal.

`C-M-x'
     Insert a byte with a code typed in hex.

`C-x ['
     Move to the beginning of a 1k-byte "page."

`C-x ]'
     Move to the end of a 1k-byte "page."

`M-g'
     Move to an address specified in hex.

`M-j'
     Move to an address specified in decimal.

`C-c C-c'
     Leave Hexl mode, going back to the major mode this buffer had
     before you invoked `hexl-mode'.


File: emacs,  Node: Saving Emacs Sessions,  Next: Recursive Edit,  Prev: Editing Binary Files,  Up: Top

Saving Emacs Sessions
=====================

   You can use the Desktop library to save the state of Emacs from one
session to another.  Saving the state means that Emacs starts up with
the same set of buffers, major modes, buffer positions, and so on that
the previous Emacs session had.

   To use Desktop, you should use the Customization buffer (*note Easy
Customization::.) to set `desktop-enable' to a non-`nil' value, or add
these lines at the end of your `.emacs' file:

     (desktop-load-default)
     (desktop-read)

The first time you save the state of the Emacs session, you must do it
manually, with the command `M-x desktop-save'.  Once you have done
that, exiting Emacs will save the state again--not only the present
Emacs session, but also subsequent sessions.  You can also save the
state at any time, without exiting Emacs, by typing `M-x desktop-save'
again.

   In order for Emacs to recover the state from a previous session, you
must start it with the same current directory as you used when you
started the previous session.  This is because `desktop-read' looks in
the current directory for the file to read.  This means that you can
have separate saved sessions in different directories; the directory in
which you start Emacs will control which saved session to use.

   The variable `desktop-files-not-to-save' controls which files are
excluded from state saving.  Its value is a regular expression that
matches the files to exclude.  By default, remote (ftp-accessed) files
are excluded; this is because visiting them again in the subsequent
session would be slow.  If you want to include these files in state
saving, set `desktop-files-not-to-save' to `"^$"'.  *Note Remote
Files::.


File: emacs,  Node: Recursive Edit,  Next: Emulation,  Prev: Saving Emacs Sessions,  Up: Top

Recursive Editing Levels
========================

   A "recursive edit" is a situation in which you are using Emacs
commands to perform arbitrary editing while in the middle of another
Emacs command.  For example, when you type `C-r' inside of a
`query-replace', you enter a recursive edit in which you can change the
current buffer.  On exiting from the recursive edit, you go back to the
`query-replace'.

   "Exiting" the recursive edit means returning to the unfinished
command, which continues execution.  The command to exit is `C-M-c'
(`exit-recursive-edit').

   You can also "abort" the recursive edit.  This is like exiting, but
also quits the unfinished command immediately.  Use the command `C-]'
(`abort-recursive-edit') to do this.  *Note Quitting::.

   The mode line shows you when you are in a recursive edit by
displaying square brackets around the parentheses that always surround
the major and minor mode names.  Every window's mode line shows this,
in the same way, since being in a recursive edit is true of Emacs as a
whole rather than any particular window or buffer.

   It is possible to be in recursive edits within recursive edits.  For
example, after typing `C-r' in a `query-replace', you may type a
command that enters the debugger.  This begins a recursive editing level
for the debugger, within the recursive editing level for `C-r'.  Mode
lines display a pair of square brackets for each recursive editing
level currently in progress.

   Exiting the inner recursive edit (such as, with the debugger `c'
command) resumes the command running in the next level up.  When that
command finishes, you can then use `C-M-c' to exit another recursive
editing level, and so on.  Exiting applies to the innermost level only.
Aborting also gets out of only one level of recursive edit; it returns
immediately to the command level of the previous recursive edit.  If you
wish, you can then abort the next recursive editing level.

   Alternatively, the command `M-x top-level' aborts all levels of
recursive edits, returning immediately to the top-level command reader.

   The text being edited inside the recursive edit need not be the same
text that you were editing at top level.  It depends on what the
recursive edit is for.  If the command that invokes the recursive edit
selects a different buffer first, that is the buffer you will edit
recursively.  In any case, you can switch buffers within the recursive
edit in the normal manner (as long as the buffer-switching keys have
not been rebound).  You could probably do all the rest of your editing
inside the recursive edit, visiting files and all.  But this could have
surprising effects (such as stack overflow) from time to time.  So
remember to exit or abort the recursive edit when you no longer need it.

   In general, we try to minimize the use of recursive editing levels in
GNU Emacs.  This is because they constrain you to "go back" in a
particular order--from the innermost level toward the top level.  When
possible, we present different activities in separate buffers so that
you can switch between them as you please.  Some commands switch to a
new major mode which provides a command to switch back.  These
approaches give you more flexibility to go back to unfinished tasks in
the order you choose.


File: emacs,  Node: Emulation,  Next: Dissociated Press,  Prev: Recursive Edit,  Up: Top

Emulation
=========

   GNU Emacs can be programmed to emulate (more or less) most other
editors.  Standard facilities can emulate these:

EDT (DEC VMS editor)
     Turn on EDT emulation with `M-x edt-emulation-on'.  `M-x
     edt-emulation-off' restores normal Emacs command bindings.

     Most of the EDT emulation commands are keypad keys, and most
     standard Emacs key bindings are still available.  The EDT
     emulation rebindings are done in the global keymap, so there is no
     problem switching buffers or major modes while in EDT emulation.

vi (Berkeley editor)
     Viper is the newest emulator for vi.  It implements several levels
     of emulation; level 1 is closest to vi itself, while level 5
     departs somewhat from strict emulation to take advantage of the
     capabilities of Emacs.  To invoke Viper, type `M-x viper-mode'; it
     will guide you the rest of the way and ask for the emulation level.

vi (another emulator)
     `M-x vi-mode' enters a major mode that replaces the previously
     established major mode.  All of the vi commands that, in real vi,
     enter "input" mode are programmed instead to return to the
     previous major mode.  Thus, ordinary Emacs serves as vi's "input"
     mode.

     Because vi emulation works through major modes, it does not work
     to switch buffers during emulation.  Return to normal Emacs first.

     If you plan to use vi emulation much, you probably want to bind a
     key to the `vi-mode' command.

vi (alternate emulator)
     `M-x vip-mode' invokes another vi emulator, said to resemble real
     vi more thoroughly than `M-x vi-mode'.  "Input" mode in this
     emulator is changed from ordinary Emacs so you can use <ESC> to go
     back to emulated vi command mode.  To get from emulated vi command
     mode back to ordinary Emacs, type `C-z'.

     This emulation does not work through major modes, and it is
     possible to switch buffers in various ways within the emulator.
     It is not so necessary to assign a key to the command `vip-mode' as
     it is with `vi-mode' because terminating insert mode does not use
     it.

     For full information, see the long comment at the beginning of the
     source file, which is `lisp/vip.el' in the Emacs distribution.


File: emacs,  Node: Dissociated Press,  Next: Amusements,  Prev: Emulation,  Up: Top

Dissociated Press
=================

   `M-x dissociated-press' is a command for scrambling a file of text
either word by word or character by character.  Starting from a buffer
of straight English, it produces extremely amusing output.  The input
comes from the current Emacs buffer.  Dissociated Press writes its
output in a buffer named `*Dissociation*', and redisplays that buffer
after every couple of lines (approximately) so you can read the output
as it comes out.

   Dissociated Press asks every so often whether to continue generating
output.  Answer `n' to stop it.  You can also stop at any time by
typing `C-g'.  The dissociation output remains in the `*Dissociation*'
buffer for you to copy elsewhere if you wish.

   Dissociated Press operates by jumping at random from one point in the
buffer to another.  In order to produce plausible output rather than
gibberish, it insists on a certain amount of overlap between the end of
one run of consecutive words or characters and the start of the next.
That is, if it has just printed out `president' and then decides to jump
to a different point in the file, it might spot the `ent' in `pentagon'
and continue from there, producing `presidentagon'.(1)  Long sample
texts produce the best results.

   A positive argument to `M-x dissociated-press' tells it to operate
character by character, and specifies the number of overlap characters.
A negative argument tells it to operate word by word and specifies the
number of overlap words.  In this mode, whole words are treated as the
elements to be permuted, rather than characters.  No argument is
equivalent to an argument of two.  For your againformation, the output
goes only into the buffer `*Dissociation*'.  The buffer you start with
is not changed.

   Dissociated Press produces nearly the same results as a Markov chain
based on a frequency table constructed from the sample text.  It is,
however, an independent, ignoriginal invention.  Dissociated Press
techniquitously copies several consecutive characters from the sample
between random choices, whereas a Markov chain would choose randomly for
each word or character.  This makes for more plausible sounding results,
and runs faster.

   It is a mustatement that too much use of Dissociated Press can be a
developediment to your real work.  Sometimes to the point of outragedy.
And keep dissociwords out of your documentation, if you want it to be
well userenced and properbose.  Have fun.  Your buggestions are welcome.

   ---------- Footnotes ----------

   (1) This dissociword actually appeared during the Vietnam War, when
it was very appropriate.


File: emacs,  Node: Amusements,  Next: Customization,  Prev: Dissociated Press,  Up: Top

Other Amusements
================

   If you are a little bit bored, you can try `M-x hanoi'.  If you are
considerably bored, give it a numeric argument.  If you are very very
bored, try an argument of 9.  Sit back and watch.

   If you want a little more personal involvement, try `M-x gomoku',
which plays the game Go Moku with you.

   `M-x blackbox' and `M-x mpuz' are two kinds of puzzles.  `blackbox'
challenges you to determine the location of objects inside a box by
tomography.  `mpuz' displays a multiplication puzzle with letters
standing for digits in a code that you must guess--to guess a value,
type a letter and then the digit you think it stands for.

   `M-x dunnet' runs an adventure-style exploration game, which is a
bigger sort of puzzle.

   When you are frustrated, try the famous Eliza program.  Just do `M-x
doctor'.  End each input by typing <RET> twice.

   When you are feeling strange, type `M-x yow'.


File: emacs,  Node: Customization,  Next: Quitting,  Prev: Amusements,  Up: Top

Customization
*************

   This chapter talks about various topics relevant to adapting the
behavior of Emacs in minor ways.  See `The Emacs Lisp Reference Manual'
for how to make more far-reaching changes.

   All kinds of customization affect only the particular Emacs session
that you do them in.  They are completely lost when you kill the Emacs
session, and have no effect on other Emacs sessions you may run at the
same time or later.  The only way an Emacs session can affect anything
outside of it is by writing a file; in particular, the only way to make
a customization "permanent" is to put something in your `.emacs' file
or other appropriate file to do the customization in each session.
*Note Init File::.

* Menu:

* Minor Modes::		Each minor mode is one feature you can turn on
			  independently of any others.
* Variables::		Many Emacs commands examine Emacs variables
			  to decide what to do; by setting variables,
			  you can control their functioning.
* Keyboard Macros::	A keyboard macro records a sequence of
			  keystrokes to be replayed with a single
			  command.
* Key Bindings::	The keymaps say what command each key runs.
			  By changing them, you can "redefine keys".
* Keyboard Translations::
                        If your keyboard passes an undesired code
			   for a key, you can tell Emacs to
			   substitute another code.
* Syntax::		The syntax table controls how words and
			   expressions are parsed.
* Init File::		How to write common customizations in the
			  `.emacs' file.


File: emacs,  Node: Minor Modes,  Next: Variables,  Up: Customization

Minor Modes
===========

   Minor modes are optional features which you can turn on or off.  For
example, Auto Fill mode is a minor mode in which <SPC> breaks lines
between words as you type.  All the minor modes are independent of each
other and of the selected major mode.  Most minor modes say in the mode
line when they are on; for example, `Fill' in the mode line means that
Auto Fill mode is on.

   Append `-mode' to the name of a minor mode to get the name of a
command function that turns the mode on or off.  Thus, the command to
enable or disable Auto Fill mode is called `M-x auto-fill-mode'.  These
commands are usually invoked with `M-x', but you can bind keys to them
if you wish.  With no argument, the function turns the mode on if it was
off and off if it was on.  This is known as "toggling".  A positive
argument always turns the mode on, and an explicit zero argument or a
negative argument always turns it off.

   Enabling or disabling some minor modes applies only to the current
buffer; each buffer is independent of the other buffers.  Therefore, you
can enable the mode in particular buffers and disable it in others.  The
per-buffer minor modes include Abbrev mode, Auto Fill mode, Auto Save
mode, Font-Lock mode, Hscroll mode, ISO Accents mode, Outline minor
mode, Overwrite mode, and Binary Overwrite mode.

   Abbrev mode allows you to define abbreviations that automatically
expand as you type them.  For example, `amd' might expand to `abbrev
mode'.  *Note Abbrevs::, for full information.

   Auto Fill mode allows you to enter filled text without breaking lines
explicitly.  Emacs inserts newlines as necessary to prevent lines from
becoming too long.  *Note Filling::.

   Auto Save mode causes the contents of a buffer to be saved
periodically to reduce the amount of work you can lose in case of a
system crash.  *Note Auto Save::.

   Enriched mode enables editing and saving of formatted text.  *Note
Formatted Text::.

   Flyspell mode automatically highlights misspelled words.  *Note
Spelling::.

   Font-Lock mode automatically highlights certain textual units found
in programs, such as comments, strings, and function names being
defined.  This requires a window system that can display multiple fonts.
*Note Faces::.

   Hscroll mode performs horizontal scrolling automatically to keep
point on the screen.  *Note Horizontal Scrolling::.

   ISO Accents mode makes the characters ``', `'', `"', `^', `/' and
`~' combine with the following letter, to produce an accented letter in
the ISO Latin-1 character set.  *Note Single-Byte European Support::.

   Outline minor mode provides the same facilities as the major mode
called Outline mode; but since it is a minor mode instead, you can
combine it with any major mode.  *Note Outline Mode::.

   Overwrite mode causes ordinary printing characters to replace
existing text instead of shoving it to the right.  For example, if
point is in front of the `B' in `FOOBAR', then in Overwrite mode typing
a `G' changes it to `FOOGAR', instead of producing `FOOGBAR' as usual.
In Overwrite mode, the command `C-q' inserts the next character
whatever it may be, even if it is a digit--this gives you a way to
insert a character instead of replacing an existing character.

   Binary Overwrite mode is a variant of Overwrite mode for editing
binary files; it treats newlines and tabs like other characters, so that
they overwrite other characters and can be overwritten by them.

   The following minor modes normally apply to all buffers at once.
Since each is enabled or disabled by the value of a variable, you *can*
set them differently for particular buffers, by explicitly making the
corresponding variables local in those buffers.  *Note Locals::.

   Icomplete mode displays an indication of available completions when
you are in the minibuffer and completion is active.  *Note Completion
Options::.

   Line Number mode enables continuous display in the mode line of the
line number of point.  *Note Mode Line::.

   Resize-Minibuffer mode makes the minibuffer expand as necessary to
hold the text that you put in it.  *Note Minibuffer Edit::.

   Scroll Bar mode gives each window a scroll bar (*note Scroll
Bars::.).  Menu Bar mode gives each frame a menu bar (*note Menu
Bars::.).  Both of these modes are enabled by default when you use the
X Window System.

   In Transient Mark mode, every change in the buffer contents
"deactivates" the mark, so that commands that operate on the region
will get an error.  This means you must either set the mark, or
explicitly "reactivate" it, before each command that uses the region.
The advantage of Transient Mark mode is that Emacs can display the
region highlighted (currently only when using X).  *Note Setting Mark::.

   For most minor modes, the command name is also the name of a variable
which directly controls the mode.  The mode is enabled whenever this
variable's value is non-`nil', and the minor-mode command works by
setting the variable.  For example, the command `outline-minor-mode'
works by setting the value of `outline-minor-mode' as a variable; it is
this variable that directly turns Outline minor mode on and off.  To
check whether a given minor mode works this way, use `C-h v' to ask for
documentation on the variable name.

   These minor-mode variables provide a good way for Lisp programs to
turn minor modes on and off; they are also useful in a file's local
variables list.  But please think twice before setting minor modes with
a local variables list, because most minor modes are matter of user
preference--other users editing the same file might not want the same
minor modes you prefer.


File: emacs,  Node: Variables,  Next: Keyboard Macros,  Prev: Minor Modes,  Up: Customization

Variables
=========

   A "variable" is a Lisp symbol which has a value.  The symbol's name
is also called the name of the variable.  A variable name can contain
any characters that can appear in a file, but conventionally variable
names consist of words separated by hyphens.  A variable can have a
documentation string which describes what kind of value it should have
and how the value will be used.

   Lisp allows any variable to have any kind of value, but most
variables that Emacs uses require a value of a certain type.  Often the
value should always be a string, or should always be a number.
Sometimes we say that a certain feature is turned on if a variable is
"non-`nil'," meaning that if the variable's value is `nil', the feature
is off, but the feature is on for *any* other value.  The conventional
value to use to turn on the feature--since you have to pick one
particular value when you set the variable--is `t'.

   Emacs uses many Lisp variables for internal record keeping, as any
Lisp program must, but the most interesting variables for you are the
ones that exist for the sake of customization.  Emacs does not (usually)
change the values of these variables; instead, you set the values, and
thereby alter and control the behavior of certain Emacs commands.  These
variables are called "user options".  Most user options are documented
in this manual, and appear in the Variable Index (*note Variable
Index::.).

   One example of a variable which is a user option is `fill-column',
which specifies the position of the right margin (as a number of
characters from the left margin) to be used by the fill commands (*note
Filling::.).

* Menu:

* Examining::	        Examining or setting one variable's value.
* Easy Customization::
                        Convenient and easy customization of variables.
* Hooks::	        Hook variables let you specify programs for parts
		          of Emacs to run on particular occasions.
* Locals::	        Per-buffer values of variables.
* File Variables::      How files can specify variable values.


File: emacs,  Node: Examining,  Next: Easy Customization,  Up: Variables

Examining and Setting Variables
-------------------------------

`C-h v VAR <RET>'
     Display the value and documentation of variable VAR
     (`describe-variable').

`M-x set-variable <RET> VAR <RET> VALUE <RET>'
     Change the value of variable VAR to VALUE.

   To examine the value of a single variable, use `C-h v'
(`describe-variable'), which reads a variable name using the
minibuffer, with completion.  It displays both the value and the
documentation of the variable.  For example,

     C-h v fill-column <RET>

displays something like this:

     fill-column's value is 75
     
     Documentation:
     *Column beyond which automatic line-wrapping should happen.
     Automatically becomes buffer-local when set in any fashion.

The star at the beginning of the documentation indicates that this
variable is a user option.  `C-h v' is not restricted to user options;
it allows any variable name.

   The most convenient way to set a specific user option is with `M-x
set-variable'.  This reads the variable name with the minibuffer (with
completion), and then reads a Lisp expression for the new value using
the minibuffer a second time.  For example,

     M-x set-variable <RET> fill-column <RET> 75 <RET>

sets `fill-column' to 75.

   `M-x set-variable' is limited to user option variables, but you can
set any variable with a Lisp expression, using the function `setq'.
Here is a `setq' expression to set `fill-column':

     (setq fill-column 75)

   To execute an expression like this one, go to the `*scratch*'
buffer, type in the expression, and then type `C-j'.  *Note Lisp
Interaction::.

   Setting variables, like all means of customizing Emacs except where
otherwise stated, affects only the current Emacs session.


File: emacs,  Node: Easy Customization,  Next: Hooks,  Prev: Examining,  Up: Variables

Easy Customization Interface
----------------------------

   A convenient way to find the user option variables that you want to
change, and then change them, is with `M-x customize'.  This command
creates a "customization buffer" with which you can browse through the
Emacs user options in a logically organized structure, then edit and
set their values.  You can also use the customization buffer to save
settings permanently.  (Not all Emacs user options are included in this
structure as of yet, but we are adding the rest.)

* Menu:

* Groups: Customization Groups.
                             How options are classified in a structure.
* Changing an Option::       How to edit a value and set an option.
* Face Customization::       How to edit the attributes of a face.
* Specific Customization::   Making a customization buffer for specific
                                options, faces, or groups.


File: emacs,  Node: Customization Groups,  Next: Changing an Option,  Up: Easy Customization

Customization Groups
....................

   For customization purposes, user options are organized into "groups"
to help you find them.  Groups are collected into bigger groups, all
the way up to a master group called `Emacs'.

   `M-x customize' creates a customization buffer that shows the
top-level `Emacs' group and the second-level groups immediately under
it.  It looks like this, in part:

     /- Emacs group: ---------------------------------------------------\
           [State]: visible group members are all at standard settings.
        Customization of the One True Editor.
        See also [Manual].
     
     Editing group: [Go to Group]
     Basic text editing facilities.
     
     External group: [Go to Group]
     Interfacing to external utilities.
     
     MORE SECOND-LEVEL GROUPS
     
     \- Emacs group end ------------------------------------------------/

This says that the buffer displays the contents of the `Emacs' group.
The other groups are listed because they are its contents.  But they
are listed differently, without indentation and dashes, because *their*
contents are not included.  Each group has a single-line documentation
string; the `Emacs' group also has a `[State]' line.

   Most of the text in the customization buffer is read-only, but it
typically includes some "editable fields" that you can edit.  There are
also "active fields"; this means a field that does something when you
"invoke" it.  To invoke an active field, either click on it with
`Mouse-1', or move point to it and type <RET>.

   For example, the phrase `[Go to Group]' that appears in a
second-level group is an active field.  Invoking the `[Go to Group]'
field for a group creates a new customization buffer, which shows that
group and its contents.  This field is a kind of hypertext link to
another group.

   The `Emacs' group does not include any user options itself, but
other groups do.  By examining various groups, you will eventually find
the options and faces that belong to the feature you are interested in
customizing.  Then you can use the customization buffer to set them.

   You can view the structure of customization groups on a larger scale
with `M-x customize-browse'.  This command creates a special kind of
customization buffer which shows only the names of the groups (and
options and faces), and their structure.

   In this buffer, you can show the contents of a group by invoking
`[+]'.  When the group contents are visible, this button changes to
`[-]'; invoking that hides the group contents.

   Each group, option or face name in this buffer has an active field
which says `[Group]', `[Option]' or `[Face]'.  Invoking that active
field creates an ordinary customization buffer showing just that group
and its contents, just that option, or just that face.  This is the way
to set values in it.


File: emacs,  Node: Changing an Option,  Next: Face Customization,  Prev: Customization Groups,  Up: Easy Customization

Changing an Option
..................

   Here is an example of what a user option looks like in the
customization buffer:

     Kill Ring Max: [Hide] 30
        [State]: this option is unchanged from its standard setting.
     Maximum length of kill ring before oldest elements are thrown away.

   The text following `[Hide]', `30' in this case, indicates the
current value of the option.  If you see `[Show]' instead of `[Hide]',
it means that the value is hidden; the customization buffer initially
hides values that take up several lines.  Invoke `[Show]' to show the
value.

   The line after the option name indicates the "customization state"
of the option: in the example above, it says you have not changed the
option yet.  The word `[State]' at the beginning of this line is
active; you can get a menu of various operations by invoking it with
`Mouse-1' or <RET>.  These operations are essential for customizing the
variable.

   The line after the `[State]' line displays the beginning of the
option's documentation string.  If there are more lines of
documentation, this line ends with `[More]'; invoke this to show the
full documentation string.

   To enter a new value for `Kill Ring Max', move point to the value
and edit it textually.  For example, you can type `M-d', then insert
another number.

   When you begin to alter the text, you will see the `[State]' line
change to say that you have edited the value:

     [State]: you have edited the value as text, but not set the option.

   Editing the value does not actually set the option variable.  To do
that, you must "set" the option.  To do this, invoke the word `[State]'
and choose `Set for Current Session'.

   The state of the option changes visibly when you set it:

     [State]: you have set this option, but not saved it for future sessions.

   You don't have to worry about specifying a value that is not valid;
setting the option checks for validity and will not really install an
unacceptable value.

   While editing a value or field that is a file name, directory name,
command name, or anything else for which completion is defined, you can
type `M-<TAB>' (`widget-complete') to do completion.

   Some options have a small fixed set of possible legitimate values.
These options don't let you edit the value textually.  Instead, an
active field `[Value Menu]' appears before the value; invoke this field
to edit the value.  For a boolean "on or off" value, the active field
says `[Toggle]', and it changes to the other value.  `[Value Menu]' and
`[Toggle]' edit the buffer; the changes take effect when you use the
`Set for Current Session' operation.

   Some options have values with complex structure.  For example, the
value of `load-path' is a list of directories.  Here is how it appears
in the customization buffer:

     Load Path:
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/site-lisp
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/site-lisp
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/leim
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/lisp
     [INS] [DEL] [Current dir?]: /build/emacs/e20/lisp
     [INS] [DEL] [Current dir?]: /build/emacs/e20/lisp/gnus
     [INS]
        [State]: this item has been changed outside the customization buffer.
     List of directories to search for files to load....

Each directory in the list appears on a separate line, and each line has
several editable or active fields.

   You can edit any of the directory names.  To delete a directory from
the list, invoke `[DEL]' on that line.  To insert a new directory in
the list, invoke `[INS]' at the point where you want to insert it.

   You can also invoke `[Current dir?]' to switch between including a
specific named directory in the path, and including `nil' in the path.
(`nil' in a search path means "try the current directory.")

   Two special commands, <TAB> and `S-<TAB>', are useful for moving
through the customization buffer.  <TAB> (`widget-forward') moves
forward to the next active or editable field; `S-<TAB>'
(`widget-backward') moves backward to the previous active or editable
field.

   Typing <RET> on an editable field also moves forward, just like
<TAB>.  The reason for this is that people have a tendency to type
<RET> when they are finished editing a field.  If you have occasion to
insert a newline in an editable field, use `C-o' or `C-q C-j',

   Setting the option changes its value in the current Emacs session;
"saving" the value changes it for future sessions as well.  This works
by writing code into your `~/.emacs' file so as to set the option
variable again each time you start Emacs.  To save the option, invoke
`[State]' and select the `Save for Future Sessions' operation.

   You can also restore the option to its standard value by invoking
`[State]' and selecting the `Reset to Standard Settings' operation.
There are actually three reset operations:

`Reset'
     If you have made some modifications and not yet set the option,
     this restores the text in the customization buffer to match the
     actual value.

`Reset to Saved'
     This restores the value of the option to the last saved value, and
     updates the text accordingly.

`Reset to Standard Settings'
     This sets the option to its standard value, and updates the text
     accordingly.  This also eliminates any saved value for the option,
     so that you will get the standard value in future Emacs sessions.

   The state of a group indicates whether anything in that group has
been edited, set or saved.  You can select `Set for Current Session',
`Save for Future Sessions' and the various kinds of `Reset' operation
for the group; these operations on the group apply to all options in
the group and its subgroups.

   Near the top of the customization buffer there are two lines
containing several active fields:

      [Set for Current Session] [Save for Future Sessions]
      [Reset] [Reset to Saved] [Reset to Standard]   [Bury Buffer]

Invoking `[Bury Buffer]' buries this customization buffer.  Each of the
other fields performs an operation--set, save or reset--on each of the
items in the buffer that could meaningfully be set, saved or reset.


File: emacs,  Node: Face Customization,  Next: Specific Customization,  Prev: Changing an Option,  Up: Easy Customization

Customizing Faces
.................

   In addition to user options, some customization groups also include
faces.  When you show the contents of a group, both the user options and
the faces in the group appear in the customization buffer.  Here is an
example of how a face looks:

     Custom Changed Face: (sample)
        [State]: this face is unchanged from its standard setting.
     Face used when the customize item has been changed.
     Attributes: [ ] Bold: [toggle] off
                 [X] Italic: [toggle] on
                 [ ] Underline: [toggle] off
                 [ ] Inverse-Video: [toggle] on
                 [ ] Foreground: black (sample)
                 [ ] Background: white (sample)
                 [ ] Stipple:

   Each face attribute has its own line.  The `[X]' field before the
attribute name indicates whether the attribute is "enabled"; `X' means
that it is.  You can enable or disable the attribute by invoking that
field.  When the attribute is enabled, you can change the attribute
value in the usual ways.

   On a black-and-white display, the colors you can use for the
background are `black', `white', `gray', `gray1', and `gray3'.  Emacs
supports these shades of gray by using background stipple patterns
instead of a color.

   Setting, saving and resetting a face work like the same operations
for options (*note Changing an Option::.).

   A face can specify different appearances for different types of
display.  For example, a face can make text red on a color display, but
use a bold font on a monochrome display.  To specify multiple
appearances for a face, select `Show Display Types' in the menu you get
from invoking `[State]'.

   Another more basic way to set the attributes of a specific face is
with `M-x modify-face'.  This command reads the name of a face, then
reads the attributes one by one.  For the color and stipple attributes,
the attribute's current value is the default--type just <RET> if you
don't want to change that attribute.  Type `none' if you want to clear
out the attribute.


File: emacs,  Node: Specific Customization,  Prev: Face Customization,  Up: Easy Customization

Customizing Specific Items
..........................

   Instead of finding the options you want to change by moving down
through the structure of groups, you can specify the particular option,
face or group that you want to customize.

`M-x customize-option <RET> OPTION <RET>'
     Set up a customization buffer with just one option, OPTION.

`M-x customize-face <RET> FACE <RET>'
     Set up a customization buffer with just one face, FACE.

`M-x customize-group <RET> GROUP <RET>'
     Set up a customization buffer with just one group, GROUP.

`M-x customize-apropos <RET> REGEXP <RET>'
     Set up a customization buffer with all the options, faces and
     groups that match REGEXP.

`M-x customize-changed-options <RET> VERSION <RET>'
     Set up a customization buffer with all the options, faces and
     groups whose meaning has changed since Emacs version VERSION.

`M-x customize-saved'
     Set up a customization buffer containing all options and faces
     that you have saved with customization buffers.

`M-x customize-customized'
     Set up a customization buffer containing all options and faces
     that you have customized but not saved.

   If you want to alter a particular user option variable with the
customization buffer, and you know its name, you can use the command
`M-x customize-option' and specify the option name.  This sets up the
customization buffer with just one option--the one that you asked for.
Editing, setting and saving the value work as described above, but only
for the specified option.

   Likewise, you can modify a specific face, chosen by name, using `M-x
customize-face'.

   You can also set up the customization buffer with a specific group,
using `M-x customize-group'.  The immediate contents of the chosen
group, including option variables, faces, and other groups, all appear
as well.  However, these subgroups' own contents start out hidden.  You
can show their contents in the usual way, by invoking `[Show]'.

   To control more precisely what to customize, you can use `M-x
customize-apropos'.  You specify a regular expression as argument; then
all options, faces and groups whose names match this regular expression
are set up in the customization buffer.  If you specify an empty regular
expression, this includes *all* groups, options and faces in the
customization buffer (but that takes a long time).

   When you upgrade to a new Emacs version, you might want to customize
new options and options whose meanings or default values have changed.
To do this, use `M-x customize-changed-options' and specify a previous
Emacs version number using the minibuffer.  It creates a customization
buffer which shows all the options (and groups) whose definitions have
been changed since the specified version.

   If you change option values and then decide the change was a mistake,
you can use two special commands to revisit your previous changes.  Use
`customize-saved' to look at the options and faces that you have saved.
Use `M-x customize-customized' to look at the options and faces that
you have set but not saved.


File: emacs,  Node: Hooks,  Next: Locals,  Prev: Easy Customization,  Up: Variables

Hooks
-----

   A "hook" is a variable where you can store a function or functions
to be called on a particular occasion by an existing program.  Emacs
provides a number of hooks for the sake of customization.

   Most of the hooks in Emacs are "normal hooks".  These variables
contain lists of functions to be called with no arguments.  The reason
most hooks are normal hooks is so that you can use them in a uniform
way.  Every variable in Emacs whose name ends in `-hook' is a normal
hook.

   Most major modes run hooks as the last step of initialization.  This
makes it easy for a user to customize the behavior of the mode, by
overriding the local variable assignments already made by the mode.  But
hooks may also be used in other contexts.  For example, the hook
`suspend-hook' runs just before Emacs suspends itself (*note
Exiting::.).

   The recommended way to add a hook function to a normal hook is by
calling `add-hook'.  You can use any valid Lisp function as the hook
function.  For example, here's how to set up a hook to turn on Auto
Fill mode when entering Text mode and other modes based on Text mode:

     (add-hook 'text-mode-hook 'turn-on-auto-fill)

   The next example shows how to use a hook to customize the indentation
of C code.  (People often have strong personal preferences for one
format compared to another.)  Here the hook function is an anonymous
lambda expression.

     (setq my-c-style
       '((c-comment-only-line-offset . 4)
         (c-cleanup-list . (scope-operator
     		       empty-defun-braces
     		       defun-close-semi))
         (c-offsets-alist . ((arglist-close . c-lineup-arglist)
     			(substatement-open . 0)))))
     
     (add-hook 'c-mode-common-hook
       (function (lambda ()
         (c-add-style "my-style" my-c-style t))))

   It is best to design your hook functions so that the order in which
they are executed does not matter.  Any dependence on the order is
"asking for trouble."  However, the order is predictable: the most
recently added hook functions are executed first.


File: emacs,  Node: Locals,  Next: File Variables,  Prev: Hooks,  Up: Variables

Local Variables
---------------

`M-x make-local-variable <RET> VAR <RET>'
     Make variable VAR have a local value in the current buffer.

`M-x kill-local-variable <RET> VAR <RET>'
     Make variable VAR use its global value in the current buffer.

`M-x make-variable-buffer-local <RET> VAR <RET>'
     Mark variable VAR so that setting it will make it local to the
     buffer that is current at that time.

   Almost any variable can be made "local" to a specific Emacs buffer.
This means that its value in that buffer is independent of its value in
other buffers.  A few variables are always local in every buffer.
Every other Emacs variable has a "global" value which is in effect in
all buffers that have not made the variable local.

   `M-x make-local-variable' reads the name of a variable and makes it
local to the current buffer.  Further changes in this buffer will not
affect others, and further changes in the global value will not affect
this buffer.

   `M-x make-variable-buffer-local' reads the name of a variable and
changes the future behavior of the variable so that it will become local
automatically when it is set.  More precisely, once a variable has been
marked in this way, the usual ways of setting the variable automatically
do `make-local-variable' first.  We call such variables "per-buffer"
variables.

   Major modes (*note Major Modes::.) always make variables local to the
buffer before setting the variables.  This is why changing major modes
in one buffer has no effect on other buffers.  Minor modes also work by
setting variables--normally, each minor mode has one controlling
variable which is non-`nil' when the mode is enabled (*note Minor
Modes::.).  For most minor modes, the controlling variable is per
buffer.

   Emacs contains a number of variables that are always per-buffer.
These include `abbrev-mode', `auto-fill-function', `case-fold-search',
`comment-column', `ctl-arrow', `fill-column', `fill-prefix',
`indent-tabs-mode', `left-margin', `mode-line-format', `overwrite-mode',
`selective-display-ellipses', `selective-display', `tab-width', and
`truncate-lines'.  Some other variables are always local in every
buffer, but they are used for internal purposes.

   A few variables cannot be local to a buffer because they are always
local to each display instead (*Note Multiple Displays::).  If you try
to make one of these variables buffer-local, you'll get an error
message.

   `M-x kill-local-variable' reads the name of a variable and makes it
cease to be local to the current buffer.  The global value of the
variable henceforth is in effect in this buffer.  Setting the major mode
kills all the local variables of the buffer except for a few variables
specially marked as "permanent locals".

   To set the global value of a variable, regardless of whether the
variable has a local value in the current buffer, you can use the Lisp
construct `setq-default'.  This construct is used just like `setq', but
it sets variables' global values instead of their local values (if
any).  When the current buffer does have a local value, the new global
value may not be visible until you switch to another buffer.  Here is
an example:

     (setq-default fill-column 75)

`setq-default' is the only way to set the global value of a variable
that has been marked with `make-variable-buffer-local'.

   Lisp programs can use `default-value' to look at a variable's
default value.  This function takes a symbol as argument and returns its
default value.  The argument is evaluated; usually you must quote it
explicitly.  For example, here's how to obtain the default value of
`fill-column':

     (default-value 'fill-column)

